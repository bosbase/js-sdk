class ClientResponseError extends Error{constructor(e){super("ClientResponseError"),this.url="",this.status=0,this.response={},this.isAbort=!1,this.originalError=null,Object.setPrototypeOf(this,ClientResponseError.prototype),null!==e&&"object"==typeof e&&(this.url="string"==typeof e.url?e.url:"",this.status="number"==typeof e.status?e.status:0,this.isAbort=!!e.isAbort,this.originalError=e.originalError,null!==e.response&&"object"==typeof e.response?this.response=e.response:null!==e.data&&"object"==typeof e.data?this.response=e.data:this.response={}),this.originalError||e instanceof ClientResponseError||(this.originalError=e),"undefined"!=typeof DOMException&&e instanceof DOMException&&(this.isAbort=!0),this.name="ClientResponseError "+this.status,this.message=this.response?.message,this.message||(this.isAbort?this.message="The request was autocancelled. You can find more info in https://github.com/bosbase/js-sdk#auto-cancellation.":this.originalError?.cause?.message?.includes("ECONNREFUSED ::1")?this.message="Failed to connect to the BosBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/bosbase/js-sdk/issues/21).":this.message="Something went wrong."),this.cause=this.originalError}get data(){return this.response}toJSON(){return{...this}}}const e=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;function cookieParse(e,t){const s={};if("string"!=typeof e)return s;const n=Object.assign({},t||{}).decode||defaultDecode;let i=0;for(;i<e.length;){const t=e.indexOf("=",i);if(-1===t)break;let r=e.indexOf(";",i);if(-1===r)r=e.length;else if(r<t){i=e.lastIndexOf(";",t-1)+1;continue}const o=e.slice(i,t).trim();if(void 0===s[o]){let i=e.slice(t+1,r).trim();34===i.charCodeAt(0)&&(i=i.slice(1,-1));try{s[o]=n(i)}catch(e){s[o]=i}}i=r+1}return s}function cookieSerialize(t,s,n){const i=Object.assign({},n||{}),r=i.encode||defaultEncode;if(!e.test(t))throw new TypeError("argument name is invalid");const o=r(s);if(o&&!e.test(o))throw new TypeError("argument val is invalid");let a=t+"="+o;if(null!=i.maxAge){const e=i.maxAge-0;if(isNaN(e)||!isFinite(e))throw new TypeError("option maxAge is invalid");a+="; Max-Age="+Math.floor(e)}if(i.domain){if(!e.test(i.domain))throw new TypeError("option domain is invalid");a+="; Domain="+i.domain}if(i.path){if(!e.test(i.path))throw new TypeError("option path is invalid");a+="; Path="+i.path}if(i.expires){if(!function isDate(e){return"[object Date]"===Object.prototype.toString.call(e)||e instanceof Date}(i.expires)||isNaN(i.expires.valueOf()))throw new TypeError("option expires is invalid");a+="; Expires="+i.expires.toUTCString()}if(i.httpOnly&&(a+="; HttpOnly"),i.secure&&(a+="; Secure"),i.priority){switch("string"==typeof i.priority?i.priority.toLowerCase():i.priority){case"low":a+="; Priority=Low";break;case"medium":a+="; Priority=Medium";break;case"high":a+="; Priority=High";break;default:throw new TypeError("option priority is invalid")}}if(i.sameSite){switch("string"==typeof i.sameSite?i.sameSite.toLowerCase():i.sameSite){case!0:a+="; SameSite=Strict";break;case"lax":a+="; SameSite=Lax";break;case"strict":a+="; SameSite=Strict";break;case"none":a+="; SameSite=None";break;default:throw new TypeError("option sameSite is invalid")}}return a}function defaultDecode(e){return-1!==e.indexOf("%")?decodeURIComponent(e):e}function defaultEncode(e){return encodeURIComponent(e)}const t="undefined"!=typeof navigator&&"ReactNative"===navigator.product||"undefined"!=typeof global&&global.HermesInternal;let s;function getTokenPayload(e){if(e)try{const t=decodeURIComponent(s(e.split(".")[1]).split("").map(function(e){return"%"+("00"+e.charCodeAt(0).toString(16)).slice(-2)}).join(""));return JSON.parse(t)||{}}catch(e){}return{}}function isTokenExpired(e,t=0){let s=getTokenPayload(e);return!(Object.keys(s).length>0&&(!s.exp||s.exp-t>Date.now()/1e3))}s="function"!=typeof atob||t?e=>{let t=String(e).replace(/=+$/,"");if(t.length%4==1)throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");for(var s,n,i=0,r=0,o="";n=t.charAt(r++);~n&&(s=i%4?64*s+n:n,i++%4)?o+=String.fromCharCode(255&s>>(-2*i&6)):0)n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(n);return o}:atob;const n="pb_auth";class BaseAuthStore{constructor(){this.baseToken="",this.baseModel=null,this._onChangeCallbacks=[]}get token(){return this.baseToken}get record(){return this.baseModel}get model(){return this.baseModel}get isValid(){return!isTokenExpired(this.token)}get isSuperuser(){let e=getTokenPayload(this.token);return"auth"==e.type&&("_superusers"==this.record?.collectionName||!this.record?.collectionName&&"pbc_3142635823"==e.collectionId)}get isAdmin(){return console.warn("Please replace pb.authStore.isAdmin with pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName"),this.isSuperuser}get isAuthRecord(){return console.warn("Please replace pb.authStore.isAuthRecord with !pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName"),"auth"==getTokenPayload(this.token).type&&!this.isSuperuser}save(e,t){this.baseToken=e||"",this.baseModel=t||null,this.triggerChange()}clear(){this.baseToken="",this.baseModel=null,this.triggerChange()}loadFromCookie(e,t=n){const s=cookieParse(e||"")[t]||"";let i={};try{i=JSON.parse(s),(null===typeof i||"object"!=typeof i||Array.isArray(i))&&(i={})}catch(e){}this.save(i.token||"",i.record||i.model||null)}exportToCookie(e,t=n){const s={secure:!0,sameSite:!0,httpOnly:!0,path:"/"},i=getTokenPayload(this.token);s.expires=i?.exp?new Date(1e3*i.exp):new Date("1970-01-01"),e=Object.assign({},s,e);const r={token:this.token,record:this.record?JSON.parse(JSON.stringify(this.record)):null};let o=cookieSerialize(t,JSON.stringify(r),e);const a="undefined"!=typeof Blob?new Blob([o]).size:o.length;if(r.record&&a>4096){r.record={id:r.record?.id,email:r.record?.email};const s=["collectionId","collectionName","verified"];for(const e in this.record)s.includes(e)&&(r.record[e]=this.record[e]);o=cookieSerialize(t,JSON.stringify(r),e)}return o}onChange(e,t=!1){return this._onChangeCallbacks.push(e),t&&e(this.token,this.record),()=>{for(let t=this._onChangeCallbacks.length-1;t>=0;t--)if(this._onChangeCallbacks[t]==e)return delete this._onChangeCallbacks[t],void this._onChangeCallbacks.splice(t,1)}}triggerChange(){for(const e of this._onChangeCallbacks)e&&e(this.token,this.record)}}class LocalAuthStore extends BaseAuthStore{constructor(e="bosbase_auth"){super(),this.storageFallback={},this.storageKey=e,this._bindStorageEvent()}get token(){return(this._storageGet(this.storageKey)||{}).token||""}get record(){const e=this._storageGet(this.storageKey)||{};return e.record||e.model||null}get model(){return this.record}save(e,t){this._storageSet(this.storageKey,{token:e,record:t}),super.save(e,t)}clear(){this._storageRemove(this.storageKey),super.clear()}_storageGet(e){if("undefined"!=typeof window&&window?.localStorage){const t=window.localStorage.getItem(e)||"";try{return JSON.parse(t)}catch(e){return t}}return this.storageFallback[e]}_storageSet(e,t){if("undefined"!=typeof window&&window?.localStorage){let s=t;"string"!=typeof t&&(s=JSON.stringify(t)),window.localStorage.setItem(e,s)}else this.storageFallback[e]=t}_storageRemove(e){"undefined"!=typeof window&&window?.localStorage&&window.localStorage?.removeItem(e),delete this.storageFallback[e]}_bindStorageEvent(){"undefined"!=typeof window&&window?.localStorage&&window.addEventListener&&window.addEventListener("storage",e=>{if(e.key!=this.storageKey)return;const t=this._storageGet(this.storageKey)||{};super.save(t.token||"",t.record||t.model||null)})}}class BaseService{constructor(e){this.client=e}}class SettingsService extends BaseService{async getAll(e){return e=Object.assign({method:"GET"},e),this.client.send("/api/settings",e)}async update(e,t){return t=Object.assign({method:"PATCH",body:e},t),this.client.send("/api/settings",t)}async testS3(e="storage",t){return t=Object.assign({method:"POST",body:{filesystem:e}},t),this.client.send("/api/settings/test/s3",t).then(()=>!0)}async testEmail(e,t,s,n){return n=Object.assign({method:"POST",body:{email:t,template:s,collection:e}},n),this.client.send("/api/settings/test/email",n).then(()=>!0)}async generateAppleClientSecret(e,t,s,n,i,r){return r=Object.assign({method:"POST",body:{clientId:e,teamId:t,keyId:s,privateKey:n,duration:i}},r),this.client.send("/api/settings/apple/generate-client-secret",r)}async getCategory(e,t){return(await this.getAll(t))[e]||null}async updateMeta(e,t){return this.update({meta:e},t)}async getApplicationSettings(e){const t=await this.getAll(e);return{meta:t.meta,trustedProxy:t.trustedProxy,rateLimits:t.rateLimits,batch:t.batch}}async updateApplicationSettings(e,t){return this.update(e,t)}async updateSMTP(e,t){return this.update({smtp:e},t)}async getMailSettings(e){const t=await this.getAll(e);return{meta:{senderName:t.meta?.senderName,senderAddress:t.meta?.senderAddress},smtp:t.smtp}}async updateMailSettings(e,t){const s={};return void 0===e.senderName&&void 0===e.senderAddress||(s.meta={},void 0!==e.senderName&&(s.meta.senderName=e.senderName),void 0!==e.senderAddress&&(s.meta.senderAddress=e.senderAddress)),void 0!==e.smtp&&(s.smtp=e.smtp),this.update(s,t)}async testMail(e,t="verification",s="_superusers",n){return this.testEmail(s,e,t,n)}async updateS3(e,t){return this.update({s3:e},t)}async getStorageS3(e){return this.getCategory("s3",e)}async updateStorageS3(e,t){return this.updateS3(e,t)}async testStorageS3(e){return this.testS3("storage",e)}async updateBackups(e,t){return this.update({backups:e},t)}async getBackupSettings(e){return(await this.getAll(e)).backups||{}}async updateBackupSettings(e,t){return this.updateBackups(e,t)}async setAutoBackupSchedule(e,t,s){const n={cron:e||""};return void 0!==t&&(n.cronMaxKeep=t),this.updateBackups(n,s)}async disableAutoBackup(e){return this.updateBackups({cron:""},e)}async testBackupsS3(e){return this.testS3("backups",e)}async updateBatch(e,t){return this.update({batch:e},t)}async updateRateLimits(e,t){return this.update({rateLimits:e},t)}async updateTrustedProxy(e,t){return this.update({trustedProxy:e},t)}async updateLogs(e,t){return this.update({logs:e},t)}async getLogSettings(e){return(await this.getAll(e)).logs||{}}async updateLogSettings(e,t){return this.updateLogs(e,t)}async setLogRetentionDays(e,t){return this.updateLogs({maxDays:e},t)}async setMinLogLevel(e,t){return this.updateLogs({minLevel:e},t)}async setLogIPAddresses(e,t){return this.updateLogs({logIP:e},t)}async setLogAuthIds(e,t){return this.updateLogs({logAuthId:e},t)}}const i=["requestKey","$cancelKey","$autoCancel","fetch","headers","body","query","params","cache","credentials","headers","integrity","keepalive","method","mode","redirect","referrer","referrerPolicy","signal","window"];function normalizeUnknownQueryParams(e){if(e){e.query=e.query||{};for(let t in e)i.includes(t)||(e.query[t]=e[t],delete e[t])}}function serializeQueryParams(e){const t=[];for(const s in e){const n=encodeURIComponent(s),i=Array.isArray(e[s])?e[s]:[e[s]];for(let e of i)e=prepareQueryParamValue(e),null!==e&&t.push(n+"="+e)}return t.join("&")}function prepareQueryParamValue(e){return null==e?null:e instanceof Date?encodeURIComponent(e.toISOString().replace("T"," ")):"object"==typeof e?encodeURIComponent(JSON.stringify(e)):encodeURIComponent(e)}class RealtimeService extends BaseService{constructor(){super(...arguments),this.clientId="",this.eventSource=null,this.subscriptions={},this.lastSentSubscriptions=[],this.maxConnectTimeout=15e3,this.reconnectAttempts=0,this.maxReconnectAttempts=1/0,this.predefinedReconnectIntervals=[200,300,500,1e3,1200,1500,2e3],this.pendingConnects=[]}get isConnected(){return!!this.eventSource&&!!this.clientId&&!this.pendingConnects.length}async subscribe(e,t,s){if(!e)throw new Error("topic must be set.");let n=e;if(s){normalizeUnknownQueryParams(s=Object.assign({},s));const e="options="+encodeURIComponent(JSON.stringify({query:s.query,headers:s.headers}));n+=(n.includes("?")?"&":"?")+e}const listener=function(e){const s=e;let n;try{n=JSON.parse(s?.data)}catch{}t(n||{})};return this.subscriptions[n]||(this.subscriptions[n]=[]),this.subscriptions[n].push(listener),this.isConnected?1===this.subscriptions[n].length?await this.submitSubscriptions():this.eventSource?.addEventListener(n,listener):await this.connect(),async()=>this.unsubscribeByTopicAndListener(e,listener)}async unsubscribe(e){let t=!1;if(e){const s=this.getSubscriptionsByTopic(e);for(let e in s)if(this.hasSubscriptionListeners(e)){for(let t of this.subscriptions[e])this.eventSource?.removeEventListener(e,t);delete this.subscriptions[e],t||(t=!0)}}else this.subscriptions={};this.hasSubscriptionListeners()?t&&await this.submitSubscriptions():this.disconnect()}async unsubscribeByPrefix(e){let t=!1;for(let s in this.subscriptions)if((s+"?").startsWith(e)){t=!0;for(let e of this.subscriptions[s])this.eventSource?.removeEventListener(s,e);delete this.subscriptions[s]}t&&(this.hasSubscriptionListeners()?await this.submitSubscriptions():this.disconnect())}async unsubscribeByTopicAndListener(e,t){let s=!1;const n=this.getSubscriptionsByTopic(e);for(let e in n){if(!Array.isArray(this.subscriptions[e])||!this.subscriptions[e].length)continue;let n=!1;for(let s=this.subscriptions[e].length-1;s>=0;s--)this.subscriptions[e][s]===t&&(n=!0,delete this.subscriptions[e][s],this.subscriptions[e].splice(s,1),this.eventSource?.removeEventListener(e,t));n&&(this.subscriptions[e].length||delete this.subscriptions[e],s||this.hasSubscriptionListeners(e)||(s=!0))}this.hasSubscriptionListeners()?s&&await this.submitSubscriptions():this.disconnect()}hasSubscriptionListeners(e){if(this.subscriptions=this.subscriptions||{},e)return!!this.subscriptions[e]?.length;for(let e in this.subscriptions)if(this.subscriptions[e]?.length)return!0;return!1}async submitSubscriptions(){if(this.clientId)return this.addAllSubscriptionListeners(),this.lastSentSubscriptions=this.getNonEmptySubscriptionKeys(),this.client.send("/api/realtime",{method:"POST",body:{clientId:this.clientId,subscriptions:this.lastSentSubscriptions},requestKey:this.getSubscriptionsCancelKey()}).catch(e=>{if(!e?.isAbort)throw e})}getSubscriptionsCancelKey(){return"realtime_"+this.clientId}getSubscriptionsByTopic(e){const t={};e=e.includes("?")?e:e+"?";for(let s in this.subscriptions)(s+"?").startsWith(e)&&(t[s]=this.subscriptions[s]);return t}getNonEmptySubscriptionKeys(){const e=[];for(let t in this.subscriptions)this.subscriptions[t].length&&e.push(t);return e}addAllSubscriptionListeners(){if(this.eventSource){this.removeAllSubscriptionListeners();for(let e in this.subscriptions)for(let t of this.subscriptions[e])this.eventSource.addEventListener(e,t)}}removeAllSubscriptionListeners(){if(this.eventSource)for(let e in this.subscriptions)for(let t of this.subscriptions[e])this.eventSource.removeEventListener(e,t)}async connect(){if(!(this.reconnectAttempts>0))return new Promise((e,t)=>{this.pendingConnects.push({resolve:e,reject:t}),this.pendingConnects.length>1||this.initConnect()})}initConnect(){this.disconnect(!0),clearTimeout(this.connectTimeoutId),this.connectTimeoutId=setTimeout(()=>{this.connectErrorHandler(new Error("EventSource connect took too long."))},this.maxConnectTimeout),this.eventSource=new EventSource(this.client.buildURL("/api/realtime")),this.eventSource.onerror=e=>{this.connectErrorHandler(new Error("Failed to establish realtime connection."))},this.eventSource.addEventListener("PB_CONNECT",e=>{const t=e;this.clientId=t?.lastEventId,this.submitSubscriptions().then(async()=>{let e=3;for(;this.hasUnsentSubscriptions()&&e>0;)e--,await this.submitSubscriptions()}).then(()=>{for(let e of this.pendingConnects)e.resolve();this.pendingConnects=[],this.reconnectAttempts=0,clearTimeout(this.reconnectTimeoutId),clearTimeout(this.connectTimeoutId);const t=this.getSubscriptionsByTopic("PB_CONNECT");for(let s in t)for(let n of t[s])n(e)}).catch(e=>{this.clientId="",this.connectErrorHandler(e)})})}hasUnsentSubscriptions(){const e=this.getNonEmptySubscriptionKeys();if(e.length!=this.lastSentSubscriptions.length)return!0;for(const t of e)if(!this.lastSentSubscriptions.includes(t))return!0;return!1}connectErrorHandler(e){if(clearTimeout(this.connectTimeoutId),clearTimeout(this.reconnectTimeoutId),!this.clientId&&!this.reconnectAttempts||this.reconnectAttempts>this.maxReconnectAttempts){for(let t of this.pendingConnects)t.reject(new ClientResponseError(e));return this.pendingConnects=[],void this.disconnect()}this.disconnect(!0);const t=this.predefinedReconnectIntervals[this.reconnectAttempts]||this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length-1];this.reconnectAttempts++,this.reconnectTimeoutId=setTimeout(()=>{this.initConnect()},t)}disconnect(e=!1){if(this.clientId&&this.onDisconnect&&this.onDisconnect(Object.keys(this.subscriptions)),clearTimeout(this.connectTimeoutId),clearTimeout(this.reconnectTimeoutId),this.removeAllSubscriptionListeners(),this.client.cancelRequest(this.getSubscriptionsCancelKey()),this.eventSource?.close(),this.eventSource=null,this.clientId="",!e){this.reconnectAttempts=0;for(let e of this.pendingConnects)e.resolve();this.pendingConnects=[]}}}class CrudService extends BaseService{decode(e){return e}async getFullList(e,t){if("number"==typeof e)return this._getFullList(e,t);let s=500;return(t=Object.assign({},e,t)).batch&&(s=t.batch,delete t.batch),this._getFullList(s,t)}async getList(e=1,t=30,s){return(s=Object.assign({method:"GET"},s)).query=Object.assign({page:e,perPage:t},s.query),this.client.send(this.baseCrudPath,s).then(e=>(e.items=e.items?.map(e=>this.decode(e))||[],e))}async getFirstListItem(e,t){return(t=Object.assign({requestKey:"one_by_filter_"+this.baseCrudPath+"_"+e},t)).query=Object.assign({filter:e,skipTotal:1},t.query),this.getList(1,1,t).then(e=>{if(!e?.items?.length)throw new ClientResponseError({status:404,response:{code:404,message:"The requested resource wasn't found.",data:{}}});return e.items[0]})}async getOne(e,t){if(!e)throw new ClientResponseError({url:this.client.buildURL(this.baseCrudPath+"/"),status:404,response:{code:404,message:"Missing required record id.",data:{}}});return t=Object.assign({method:"GET"},t),this.client.send(this.baseCrudPath+"/"+encodeURIComponent(e),t).then(e=>this.decode(e))}async create(e,t){return t=Object.assign({method:"POST",body:e},t),this.client.send(this.baseCrudPath,t).then(e=>this.decode(e))}async update(e,t,s){return s=Object.assign({method:"PATCH",body:t},s),this.client.send(this.baseCrudPath+"/"+encodeURIComponent(e),s).then(e=>this.decode(e))}async delete(e,t){return t=Object.assign({method:"DELETE"},t),this.client.send(this.baseCrudPath+"/"+encodeURIComponent(e),t).then(()=>!0)}_getFullList(e=500,t){(t=t||{}).query=Object.assign({skipTotal:1},t.query);let s=[],request=async n=>this.getList(n,e||500,t).then(e=>{const t=e.items;return s=s.concat(t),t.length==e.perPage?request(n+1):s});return request(1)}}function normalizeLegacyOptionsArgs(e,t,s,n){const i=void 0!==n;return i||void 0!==s?i?(console.warn(e),t.body=Object.assign({},t.body,s),t.query=Object.assign({},t.query,n),t):Object.assign(t,s):t}function resetAutoRefresh(e){e._resetAutoRefresh?.()}function registerAutoRefresh(e,t,s,n){resetAutoRefresh(e);const i=e.beforeSend,r=e.authStore.record,o=e.authStore.onChange((t,s)=>{(!t||s?.id!=r?.id||(s?.collectionId||r?.collectionId)&&s?.collectionId!=r?.collectionId)&&resetAutoRefresh(e)});e._resetAutoRefresh=function(){o(),e.beforeSend=i,delete e._resetAutoRefresh},e.beforeSend=async(r,o)=>{const a=e.authStore.token;if(o.query?.autoRefresh)return i?i(r,o):{url:r,sendOptions:o};let c=e.authStore.isValid;if(c&&isTokenExpired(e.authStore.token,t))try{await s()}catch(e){c=!1}c||await n();const l=o.headers||{};for(let t in l)if("authorization"==t.toLowerCase()&&a==l[t]&&e.authStore.token){l[t]=e.authStore.token;break}return o.headers=l,i?i(r,o):{url:r,sendOptions:o}}}class RecordService extends CrudService{constructor(e,t){super(e),this.collectionIdOrName=t}get baseCrudPath(){return this.baseCollectionPath+"/records"}get baseCollectionPath(){return"/api/collections/"+encodeURIComponent(this.collectionIdOrName)}get isSuperusers(){return"_superusers"==this.collectionIdOrName||"_pbc_2773867675"==this.collectionIdOrName}async subscribe(e,t,s){if(!e)throw new Error("Missing topic.");if(!t)throw new Error("Missing subscription callback.");return this.client.realtime.subscribe(this.collectionIdOrName+"/"+e,t,s)}async unsubscribe(e){return e?this.client.realtime.unsubscribe(this.collectionIdOrName+"/"+e):this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName)}async getFullList(e,t){if("number"==typeof e)return super.getFullList(e,t);const s=Object.assign({},e,t);return super.getFullList(s)}async getList(e=1,t=30,s){return super.getList(e,t,s)}async getCount(e,t){(t=Object.assign({method:"GET"},t)).query=Object.assign({filter:e},t.query);return(await this.client.send(this.baseCrudPath+"/count",t)).count}async getFirstListItem(e,t){return super.getFirstListItem(e,t)}async getOne(e,t){return super.getOne(e,t)}async create(e,t){return super.create(e,t)}async update(e,t,s){return super.update(e,t,s).then(e=>{if(this.client.authStore.record?.id===e?.id&&(this.client.authStore.record?.collectionId===this.collectionIdOrName||this.client.authStore.record?.collectionName===this.collectionIdOrName)){let t=Object.assign({},this.client.authStore.record.expand),s=Object.assign({},this.client.authStore.record,e);t&&(s.expand=Object.assign(t,e.expand)),this.client.authStore.save(this.client.authStore.token,s)}return e})}async delete(e,t){return super.delete(e,t).then(t=>(!t||this.client.authStore.record?.id!==e||this.client.authStore.record?.collectionId!==this.collectionIdOrName&&this.client.authStore.record?.collectionName!==this.collectionIdOrName||this.client.authStore.clear(),t))}authResponse(e){const t=this.decode(e?.record||{});return this.client.authStore.save(e?.token,t),Object.assign({},e,{token:e?.token||"",record:t})}async listAuthMethods(e){return e=Object.assign({method:"GET",fields:"mfa,otp,password,oauth2"},e),this.client.send(this.baseCollectionPath+"/auth-methods",e)}async authWithPassword(e,t,s){let n;s=Object.assign({method:"POST",body:{identity:e,password:t}},s),this.isSuperusers&&(n=s.autoRefreshThreshold,delete s.autoRefreshThreshold,s.autoRefresh||resetAutoRefresh(this.client));let i=await this.client.send(this.baseCollectionPath+"/auth-with-password",s);return i=this.authResponse(i),n&&this.isSuperusers&&registerAutoRefresh(this.client,n,()=>this.authRefresh({autoRefresh:!0}),()=>this.authWithPassword(e,t,Object.assign({autoRefresh:!0},s))),i}async bindCustomToken(e,t,s,n){return n=Object.assign({method:"POST",body:{email:e,password:t,token:s}},n),this.client.send(this.baseCollectionPath+"/bind-token",n).then(()=>!0)}async unbindCustomToken(e,t,s,n){return n=Object.assign({method:"POST",body:{email:e,password:t,token:s}},n),this.client.send(this.baseCollectionPath+"/unbind-token",n).then(()=>!0)}async authWithToken(e,t){let s;t=Object.assign({method:"POST",body:{token:e}},t),this.isSuperusers&&(s=t.autoRefreshThreshold,delete t.autoRefreshThreshold,t.autoRefresh||resetAutoRefresh(this.client));let n=await this.client.send(this.baseCollectionPath+"/auth-with-token",t);return n=this.authResponse(n),s&&this.isSuperusers&&registerAutoRefresh(this.client,s,()=>this.authRefresh({autoRefresh:!0}),()=>this.authWithToken(e,Object.assign({autoRefresh:!0},t))),n}async authWithOAuth2Code(e,t,s,n,i,r,o){let a={method:"POST",body:{provider:e,code:t,codeVerifier:s,redirectURL:n,createData:i}};return a=normalizeLegacyOptionsArgs("This form of authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, options?).",a,r,o),this.client.send(this.baseCollectionPath+"/auth-with-oauth2",a).then(e=>this.authResponse(e))}authWithOAuth2(...e){if(e.length>1||"string"==typeof e?.[0])return console.warn("BosBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://bosbase.io/docs/authentication/#oauth2-integration."),this.authWithOAuth2Code(e?.[0]||"",e?.[1]||"",e?.[2]||"",e?.[3]||"",e?.[4]||{},e?.[5]||{},e?.[6]||{});const t=e?.[0]||{};let s=null;t.urlCallback||(s=openBrowserPopup(void 0));const n=new RealtimeService(this.client);function cleanup(){s?.close(),n.unsubscribe()}const i={},r=t.requestKey;return r&&(i.requestKey=r),this.listAuthMethods(i).then(e=>{const i=e.oauth2.providers.find(e=>e.name===t.provider);if(!i)throw new ClientResponseError(new Error(`Missing or invalid provider "${t.provider}".`));const o=this.client.buildURL("/api/oauth2-redirect"),a=r?this.client.cancelControllers?.[r]:void 0;return a&&(a.signal.onabort=()=>{cleanup()}),new Promise(async(e,r)=>{try{await n.subscribe("@oauth2",async s=>{const c=n.clientId;try{if(!s.state||c!==s.state)throw new Error("State parameters don't match.");if(s.error||!s.code)throw new Error("OAuth2 redirect error or missing code: "+s.error);const n=Object.assign({},t);delete n.provider,delete n.scopes,delete n.createData,delete n.urlCallback,a?.signal?.onabort&&(a.signal.onabort=null);const r=await this.authWithOAuth2Code(i.name,s.code,i.codeVerifier,o,t.createData,n);e(r)}catch(e){r(new ClientResponseError(e))}cleanup()});const c={state:n.clientId};t.scopes?.length&&(c.scope=t.scopes.join(" "));const l=this._replaceQueryParams(i.authURL+o,c);let h=t.urlCallback||function(e){s?s.location.href=e:s=openBrowserPopup(e)};await h(l)}catch(e){cleanup(),r(new ClientResponseError(e))}})}).catch(e=>{throw cleanup(),e})}async authRefresh(e,t){let s={method:"POST"};return s=normalizeLegacyOptionsArgs("This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).",s,e,t),this.client.send(this.baseCollectionPath+"/auth-refresh",s).then(e=>this.authResponse(e))}async requestPasswordReset(e,t,s){let n={method:"POST",body:{email:e}};return n=normalizeLegacyOptionsArgs("This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).",n,t,s),this.client.send(this.baseCollectionPath+"/request-password-reset",n).then(()=>!0)}async confirmPasswordReset(e,t,s,n,i){let r={method:"POST",body:{token:e,password:t,passwordConfirm:s}};return r=normalizeLegacyOptionsArgs("This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).",r,n,i),this.client.send(this.baseCollectionPath+"/confirm-password-reset",r).then(()=>!0)}async requestVerification(e,t,s){let n={method:"POST",body:{email:e}};return n=normalizeLegacyOptionsArgs("This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).",n,t,s),this.client.send(this.baseCollectionPath+"/request-verification",n).then(()=>!0)}async confirmVerification(e,t,s){let n={method:"POST",body:{token:e}};return n=normalizeLegacyOptionsArgs("This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).",n,t,s),this.client.send(this.baseCollectionPath+"/confirm-verification",n).then(()=>{const t=getTokenPayload(e),s=this.client.authStore.record;return s&&!s.verified&&s.id===t.id&&s.collectionId===t.collectionId&&(s.verified=!0,this.client.authStore.save(this.client.authStore.token,s)),!0})}async requestEmailChange(e,t,s){let n={method:"POST",body:{newEmail:e}};return n=normalizeLegacyOptionsArgs("This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).",n,t,s),this.client.send(this.baseCollectionPath+"/request-email-change",n).then(()=>!0)}async confirmEmailChange(e,t,s,n){let i={method:"POST",body:{token:e,password:t}};return i=normalizeLegacyOptionsArgs("This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).",i,s,n),this.client.send(this.baseCollectionPath+"/confirm-email-change",i).then(()=>{const t=getTokenPayload(e),s=this.client.authStore.record;return s&&s.id===t.id&&s.collectionId===t.collectionId&&this.client.authStore.clear(),!0})}async listExternalAuths(e,t){return this.client.collection("_externalAuths").getFullList(Object.assign({},t,{filter:this.client.filter("recordRef = {:id}",{id:e})}))}async unlinkExternalAuth(e,t,s){const n=await this.client.collection("_externalAuths").getFirstListItem(this.client.filter("recordRef = {:recordId} && provider = {:provider}",{recordId:e,provider:t}));return this.client.collection("_externalAuths").delete(n.id,s).then(()=>!0)}async requestOTP(e,t){return t=Object.assign({method:"POST",body:{email:e}},t),this.client.send(this.baseCollectionPath+"/request-otp",t)}async authWithOTP(e,t,s){return s=Object.assign({method:"POST",body:{otpId:e,password:t}},s),this.client.send(this.baseCollectionPath+"/auth-with-otp",s).then(e=>this.authResponse(e))}async impersonate(e,t,s){(s=Object.assign({method:"POST",body:{duration:t}},s)).headers=s.headers||{},s.headers.Authorization||(s.headers.Authorization=this.client.authStore.token);const n=new Client(this.client.baseURL,new BaseAuthStore,this.client.lang),i=await n.send(this.baseCollectionPath+"/impersonate/"+encodeURIComponent(e),s);return n.authStore.save(i?.token,this.decode(i?.record||{})),n}_replaceQueryParams(e,t={}){let s=e,n="";e.indexOf("?")>=0&&(s=e.substring(0,e.indexOf("?")),n=e.substring(e.indexOf("?")+1));const i={},r=n.split("&");for(const e of r){if(""==e)continue;const t=e.split("=");i[decodeURIComponent(t[0].replace(/\+/g," "))]=decodeURIComponent((t[1]||"").replace(/\+/g," "))}for(let e in t)t.hasOwnProperty(e)&&(null==t[e]?delete i[e]:i[e]=t[e]);n="";for(let e in i)i.hasOwnProperty(e)&&(""!=n&&(n+="&"),n+=encodeURIComponent(e.replace(/%20/g,"+"))+"="+encodeURIComponent(i[e].replace(/%20/g,"+")));return""!=n?s+"?"+n:s}}function openBrowserPopup(e){if("undefined"==typeof window||!window?.open)throw new ClientResponseError(new Error("Not in a browser context - please pass a custom urlCallback function."));let t=1024,s=768,n=window.innerWidth,i=window.innerHeight;t=t>n?n:t,s=s>i?i:s;let r=n/2-t/2,o=i/2-s/2;return window.open(e,"popup_window","width="+t+",height="+s+",top="+o+",left="+r+",resizable,menubar=no")}class CollectionService extends CrudService{get baseCrudPath(){return"/api/collections"}async deleteCollection(e,t){return this.delete(e,t)}async getScaffolds(e){return e=Object.assign({method:"GET"},e),this.client.send(this.baseCrudPath+"/meta/scaffolds",e)}async createFromScaffold(e,t,s,n){const i=(await this.getScaffolds(n))[e];if(!i)throw new Error(`Scaffold for type "${e}" not found`);const r={...i,name:t,...s};return this.create(r,n)}async createBase(e,t,s){return this.createFromScaffold("base",e,t,s)}async createAuth(e,t,s){return this.createFromScaffold("auth",e,t,s)}async createView(e,t,s,n){const i={...s,...t?{viewQuery:t}:{}};return this.createFromScaffold("view",e,i,n)}async truncate(e,t){return t=Object.assign({method:"DELETE"},t),this.client.send(this.baseCrudPath+"/"+encodeURIComponent(e)+"/truncate",t).then(()=>!0)}async registerSqlTables(e,t){return t=Object.assign({method:"POST",body:{tables:e}},t),this.client.send(this.baseCrudPath+"/sql/tables",t)}async importSqlTables(e,t){return t=Object.assign({method:"POST",body:{tables:e}},t),this.client.send(this.baseCrudPath+"/sql/import",t)}async exportCollections(e,t){const s=await this.getFullList(t);return(e?s.filter(e):s).map(e=>{const t={...e};return delete t.created,delete t.updated,t.oauth2?.providers&&delete t.oauth2.providers,t})}normalizeForImport(e){const t=new Set;return e.filter(e=>(!e.id||!t.has(e.id))&&(e.id&&t.add(e.id),!0)).map(e=>{const t={...e};if(delete t.created,delete t.updated,Array.isArray(t.fields)){const e=new Set;t.fields=t.fields.filter(t=>(!t.id||!e.has(t.id))&&(t.id&&e.add(t.id),!0))}return t})}async import(e,t=!1,s){return s=Object.assign({method:"PUT",body:{collections:e,deleteMissing:t}},s),this.client.send(this.baseCrudPath+"/import",s).then(()=>!0)}async addField(e,t,s){const n=await this.getOne(e,s);if(!t.name||!t.type)throw new Error("Field name and type are required");if(n.fields.find(e=>e.name===t.name))throw new Error(`Field with name "${t.name}" already exists`);const i={id:"",name:t.name,type:t.type,system:!1,hidden:t.hidden??!1,presentable:t.presentable??!1,required:t.required??!1,...t};return n.fields.push(i),this.update(e,n,s)}async updateField(e,t,s,n){const i=await this.getOne(e,n),r=i.fields.findIndex(e=>e.name===t);if(-1===r)throw new Error(`Field with name "${t}" not found`);const o=i.fields[r];if(o.system&&(s.type||s.name))throw new Error("Cannot modify system fields");if(s.name&&s.name!==t&&i.fields.find(e=>e.name===s.name&&e.name!==t))throw new Error(`Field with name "${s.name}" already exists`);return Object.assign(o,s),i.fields[r]=o,this.update(e,i,n)}async removeField(e,t,s){const n=await this.getOne(e,s),i=n.fields.findIndex(e=>e.name===t);if(-1===i)throw new Error(`Field with name "${t}" not found`);if(n.fields[i].system)throw new Error("Cannot remove system fields");return n.fields.splice(i,1),n.indexes=n.indexes.filter(e=>!e.includes(`(${t})`)&&!e.includes(`(${t},`)&&!e.includes(`, ${t})`)),this.update(e,n,s)}async getField(e,t,s){return(await this.getOne(e,s)).fields.find(e=>e.name===t)}async addIndex(e,t,s=!1,n,i){const r=await this.getOne(e,i);if(!t||0===t.length)throw new Error("At least one column must be specified");const o=r.fields.map(e=>e.name);for(const e of t)if("id"!==e&&!o.includes(e))throw new Error(`Field "${e}" does not exist in the collection`);const a=n||`idx_${r.name}_${t.join("_")}`,c=t.map(e=>`\`${e}\``).join(", "),l=s?`CREATE UNIQUE INDEX \`${a}\` ON \`${r.name}\` (${c})`:`CREATE INDEX \`${a}\` ON \`${r.name}\` (${c})`;if(r.indexes.includes(l))throw new Error("Index already exists");return r.indexes.push(l),this.update(e,r,i)}async removeIndex(e,t,s){const n=await this.getOne(e,s);if(!t||0===t.length)throw new Error("At least one column must be specified");const i=n.indexes.length;if(n.indexes=n.indexes.filter(e=>!t.every(t=>e.includes(`\`${t}\``)||e.includes(`(${t})`)||e.includes(`(${t},`)||e.includes(`, ${t})`))),n.indexes.length===i)throw new Error("Index not found");return this.update(e,n,s)}async getIndexes(e,t){return(await this.getOne(e,t)).indexes||[]}async setListRule(e,t,s){const n=await this.getOne(e,s);return n.listRule=t,this.update(e,n,s)}async setViewRule(e,t,s){const n=await this.getOne(e,s);return n.viewRule=t,this.update(e,n,s)}async setCreateRule(e,t,s){const n=await this.getOne(e,s);return n.createRule=t,this.update(e,n,s)}async setUpdateRule(e,t,s){const n=await this.getOne(e,s);return n.updateRule=t,this.update(e,n,s)}async setDeleteRule(e,t,s){const n=await this.getOne(e,s);return n.deleteRule=t,this.update(e,n,s)}async setRules(e,t,s){const n=await this.getOne(e,s);return Object.prototype.hasOwnProperty.call(t,"listRule")&&(n.listRule=t.listRule),Object.prototype.hasOwnProperty.call(t,"viewRule")&&(n.viewRule=t.viewRule),Object.prototype.hasOwnProperty.call(t,"createRule")&&(n.createRule=t.createRule),Object.prototype.hasOwnProperty.call(t,"updateRule")&&(n.updateRule=t.updateRule),Object.prototype.hasOwnProperty.call(t,"deleteRule")&&(n.deleteRule=t.deleteRule),this.update(e,n,s)}async getRules(e,t){const s=await this.getOne(e,t);return{listRule:s.listRule||void 0,viewRule:s.viewRule||void 0,createRule:s.createRule||void 0,updateRule:s.updateRule||void 0,deleteRule:s.deleteRule||void 0}}async setManageRule(e,t,s){const n=await this.getOne(e,s);if("auth"!==n.type)throw new Error("ManageRule is only available for auth collections");return n.manageRule=t,this.update(e,n,s)}async setAuthRule(e,t,s){const n=await this.getOne(e,s);if("auth"!==n.type)throw new Error("AuthRule is only available for auth collections");return n.authRule=t,this.update(e,n,s)}async getSchema(e,t){return t=Object.assign({method:"GET"},t),this.client.send(this.baseCrudPath+"/"+encodeURIComponent(e)+"/schema",t)}async getAllSchemas(e){return e=Object.assign({method:"GET"},e),this.client.send(this.baseCrudPath+"/schemas",e)}async enableOAuth2(e,t){const s=await this.getOne(e,t);if("auth"!==s.type)throw new Error("OAuth2 is only available for auth collections");const n=s;return n.oauth2?n.oauth2.enabled=!0:n.oauth2={enabled:!0,mappedFields:{},providers:[]},this.update(e,s,t)}async disableOAuth2(e,t){const s=await this.getOne(e,t);if("auth"!==s.type)throw new Error("OAuth2 is only available for auth collections");const n=s;return n.oauth2&&(n.oauth2.enabled=!1),this.update(e,s,t)}async getOAuth2Config(e,t){const s=await this.getOne(e,t);if("auth"!==s.type)throw new Error("OAuth2 is only available for auth collections");const n=s;return{enabled:n.oauth2?.enabled??!1,mappedFields:n.oauth2?.mappedFields??{},providers:n.oauth2?.providers??[]}}async setOAuth2MappedFields(e,t,s){const n=await this.getOne(e,s);if("auth"!==n.type)throw new Error("OAuth2 is only available for auth collections");const i=n;return i.oauth2||(i.oauth2={enabled:!1,mappedFields:{},providers:[]}),i.oauth2.mappedFields=t,this.update(e,n,s)}async addOAuth2Provider(e,t,s){const n=await this.getOne(e,s);if("auth"!==n.type)throw new Error("OAuth2 is only available for auth collections");const i=n;i.oauth2||(i.oauth2={enabled:!1,mappedFields:{},providers:[]});if(i.oauth2.providers.find(e=>e.name===t.name))throw new Error(`OAuth2 provider with name "${t.name}" already exists`);return i.oauth2.providers.push({name:t.name,clientId:t.clientId,clientSecret:t.clientSecret,authURL:t.authURL,tokenURL:t.tokenURL,userInfoURL:t.userInfoURL,displayName:t.displayName||t.name,pkce:t.pkce,extra:t.extra}),this.update(e,n,s)}async updateOAuth2Provider(e,t,s,n){const i=await this.getOne(e,n);if("auth"!==i.type)throw new Error("OAuth2 is only available for auth collections");const r=i;if(!r.oauth2)throw new Error("OAuth2 is not configured for this collection");const o=r.oauth2.providers.findIndex(e=>e.name===t);if(-1===o)throw new Error(`OAuth2 provider with name "${t}" not found`);const a=r.oauth2.providers[o];return Object.assign(a,s),r.oauth2.providers[o]=a,this.update(e,i,n)}async removeOAuth2Provider(e,t,s){const n=await this.getOne(e,s);if("auth"!==n.type)throw new Error("OAuth2 is only available for auth collections");const i=n;if(!i.oauth2)throw new Error("OAuth2 is not configured for this collection");const r=i.oauth2.providers.findIndex(e=>e.name===t);if(-1===r)throw new Error(`OAuth2 provider with name "${t}" not found`);return i.oauth2.providers.splice(r,1),this.update(e,n,s)}}class LogService extends BaseService{async getList(e=1,t=30,s){return(s=Object.assign({method:"GET"},s)).query=Object.assign({page:e,perPage:t},s.query),this.client.send("/api/logs",s)}async getOne(e,t){if(!e)throw new ClientResponseError({url:this.client.buildURL("/api/logs/"),status:404,response:{code:404,message:"Missing required log id.",data:{}}});return t=Object.assign({method:"GET"},t),this.client.send("/api/logs/"+encodeURIComponent(e),t)}async getStats(e){return e=Object.assign({method:"GET"},e),this.client.send("/api/logs/stats",e)}}class HealthService extends BaseService{async check(e){return e=Object.assign({method:"GET"},e),this.client.send("/api/health",e)}}class FileService extends BaseService{getUrl(e,t,s={}){return console.warn("Please replace pb.files.getUrl() with pb.files.getURL()"),this.getURL(e,t,s)}getURL(e,t,s={}){if(!t||!e?.id||!e?.collectionId&&!e?.collectionName)return"";const n=[];n.push("api"),n.push("files"),n.push(encodeURIComponent(e.collectionId||e.collectionName)),n.push(encodeURIComponent(e.id)),n.push(encodeURIComponent(t));let i=this.client.buildURL(n.join("/"));if(Object.keys(s).length){!1===s.download&&delete s.download;const e=new URLSearchParams(s);i+=(i.includes("?")?"&":"?")+e}return i}async getToken(e){return e=Object.assign({method:"POST"},e),this.client.send("/api/files/token",e).then(e=>e?.token||"")}}class BackupService extends BaseService{async getFullList(e){return e=Object.assign({method:"GET"},e),this.client.send("/api/backups",e)}async create(e,t){return t=Object.assign({method:"POST",body:{name:e}},t),this.client.send("/api/backups",t).then(()=>!0)}async upload(e,t){return t=Object.assign({method:"POST",body:e},t),this.client.send("/api/backups/upload",t).then(()=>!0)}async delete(e,t){return t=Object.assign({method:"DELETE"},t),this.client.send(`/api/backups/${encodeURIComponent(e)}`,t).then(()=>!0)}async restore(e,t){return t=Object.assign({method:"POST"},t),this.client.send(`/api/backups/${encodeURIComponent(e)}/restore`,t).then(()=>!0)}getDownloadUrl(e,t){return console.warn("Please replace pb.backups.getDownloadUrl() with pb.backups.getDownloadURL()"),this.getDownloadURL(e,t)}getDownloadURL(e,t){return this.client.buildURL(`/api/backups/${encodeURIComponent(t)}?token=${encodeURIComponent(e)}`)}}class CronService extends BaseService{async getFullList(e){return e=Object.assign({method:"GET"},e),this.client.send("/api/crons",e)}async run(e,t){return t=Object.assign({method:"POST"},t),this.client.send(`/api/crons/${encodeURIComponent(e)}`,t).then(()=>!0)}}function isFile(e){return"undefined"!=typeof Blob&&e instanceof Blob||"undefined"!=typeof File&&e instanceof File||null!==e&&"object"==typeof e&&e.uri&&("undefined"!=typeof navigator&&"ReactNative"===navigator.product||"undefined"!=typeof global&&global.HermesInternal)}function isFormData(e){return e&&("FormData"===e.constructor?.name||"undefined"!=typeof FormData&&e instanceof FormData)}function hasFileField(e){for(const t in e){const s=Array.isArray(e[t])?e[t]:[e[t]];for(const e of s)if(isFile(e))return!0}return!1}const r=/^[\-\.\d]+$/;function inferFormDataValue(e){if("string"!=typeof e)return e;if("true"==e)return!0;if("false"==e)return!1;if(("-"===e[0]||e[0]>="0"&&e[0]<="9")&&r.test(e)){let t=+e;if(""+t===e)return t}return e}class BatchService extends BaseService{constructor(){super(...arguments),this.requests=[],this.subs={}}collection(e){return this.subs[e]||(this.subs[e]=new SubBatchService(this.requests,e)),this.subs[e]}async send(e){const t=new FormData,s=[];for(let e=0;e<this.requests.length;e++){const n=this.requests[e];if(s.push({method:n.method,url:n.url,headers:n.headers,body:n.json}),n.files)for(let s in n.files){const i=n.files[s]||[];for(let n of i)t.append("requests."+e+"."+s,n)}}return t.append("@jsonPayload",JSON.stringify({requests:s})),e=Object.assign({method:"POST",body:t},e),this.client.send("/api/batch",e)}}class SubBatchService{constructor(e,t){this.requests=[],this.requests=e,this.collectionIdOrName=t}upsert(e,t){t=Object.assign({body:e||{}},t);const s={method:"PUT",url:"/api/collections/"+encodeURIComponent(this.collectionIdOrName)+"/records"};this.prepareRequest(s,t),this.requests.push(s)}create(e,t){t=Object.assign({body:e||{}},t);const s={method:"POST",url:"/api/collections/"+encodeURIComponent(this.collectionIdOrName)+"/records"};this.prepareRequest(s,t),this.requests.push(s)}update(e,t,s){s=Object.assign({body:t||{}},s);const n={method:"PATCH",url:"/api/collections/"+encodeURIComponent(this.collectionIdOrName)+"/records/"+encodeURIComponent(e)};this.prepareRequest(n,s),this.requests.push(n)}delete(e,t){t=Object.assign({},t);const s={method:"DELETE",url:"/api/collections/"+encodeURIComponent(this.collectionIdOrName)+"/records/"+encodeURIComponent(e)};this.prepareRequest(s,t),this.requests.push(s)}prepareRequest(e,t){if(normalizeUnknownQueryParams(t),e.headers=t.headers,e.json={},e.files={},void 0!==t.query){const s=serializeQueryParams(t.query);s&&(e.url+=(e.url.includes("?")?"&":"?")+s)}let s=t.body;isFormData(s)&&(s=function convertFormDataToObject(e){let t={};return e.forEach((e,s)=>{if("@jsonPayload"===s&&"string"==typeof e)try{let s=JSON.parse(e);Object.assign(t,s)}catch(e){console.warn("@jsonPayload error:",e)}else void 0!==t[s]?(Array.isArray(t[s])||(t[s]=[t[s]]),t[s].push(inferFormDataValue(e))):t[s]=inferFormDataValue(e)}),t}(s));for(const t in s){const n=s[t];if(isFile(n))e.files[t]=e.files[t]||[],e.files[t].push(n);else if(Array.isArray(n)){const s=[],i=[];for(const e of n)isFile(e)?s.push(e):i.push(e);if(s.length>0&&s.length==n.length){e.files[t]=e.files[t]||[];for(let n of s)e.files[t].push(n)}else if(e.json[t]=i,s.length>0){let n=t;t.startsWith("+")||t.endsWith("+")||(n+="+"),e.files[n]=e.files[n]||[];for(let t of s)e.files[n].push(t)}}else e.json[t]=n}}}class VectorService extends BaseService{get baseVectorPath(){return"/api/vectors"}requireCollection(e){const t=e?.collection;if(!t)throw new Error("collection is required for this operation");return t}getPath(e){return e?`${this.baseVectorPath}/${encodeURIComponent(e)}`:this.baseVectorPath}async insert(e,t){const s=this.getPath(this.requireCollection(t));return this.client.send(s,{method:"POST",body:e,...t})}async batchInsert(e,t){const s=`${this.getPath(this.requireCollection(t))}/documents/batch`;return this.client.send(s,{method:"POST",body:e,...t})}async update(e,t,s){const n=`${this.getPath(this.requireCollection(s))}/${encodeURIComponent(e)}`;return this.client.send(n,{method:"PATCH",body:t,...s})}async delete(e,t){const s=`${this.getPath(this.requireCollection(t))}/${encodeURIComponent(e)}`;await this.client.send(s,{method:"DELETE",...t})}async search(e,t){const s=`${this.getPath(this.requireCollection(t))}/documents/search`;return this.client.send(s,{method:"POST",body:e,...t})}async get(e,t){const s=`${this.getPath(this.requireCollection(t))}/${encodeURIComponent(e)}`;return this.client.send(s,{method:"GET",...t})}async list(e){const t=this.requireCollection(e),s=this.getPath(t);return this.client.send(s,{method:"GET",query:{page:e?.page,perPage:e?.perPage,...e?.query??{}},...e})}async createCollection(e,t,s){const n=`${this.getPath()}/collections/${encodeURIComponent(e)}`;await this.client.send(n,{method:"POST",body:t||{},...s})}async updateCollection(e,t,s){const n=`${this.getPath()}/collections/${encodeURIComponent(e)}`;await this.client.send(n,{method:"PATCH",body:t||{},...s})}async deleteCollection(e,t){const s=`${this.getPath()}/collections/${encodeURIComponent(e)}`;await this.client.send(s,{method:"DELETE",...t})}async listCollections(e){const t=`${this.getPath()}/collections`;return this.client.send(t,{method:"GET",...e})}}class LLMDocumentService extends BaseService{get basePath(){return"/api/llm-documents"}collectionsPath(){return`${this.basePath}/collections`}collectionPath(e){if(!e)throw new Error("collection is required");return`${this.basePath}/${encodeURIComponent(e)}`}async listCollections(e){return this.client.send(this.collectionsPath(),{method:"GET",...e})}async createCollection(e,t,s){await this.client.send(`${this.collectionsPath()}/${encodeURIComponent(e)}`,{method:"POST",body:{metadata:t},...s})}async deleteCollection(e,t){await this.client.send(`${this.collectionsPath()}/${encodeURIComponent(e)}`,{method:"DELETE",...t})}async insert(e,t){return this.client.send(this.collectionPath(t.collection),{method:"POST",body:e,...t})}async get(e,t){return this.client.send(`${this.collectionPath(t.collection)}/${encodeURIComponent(e)}`,{method:"GET",...t})}async update(e,t,s){return this.client.send(`${this.collectionPath(s.collection)}/${encodeURIComponent(e)}`,{method:"PATCH",body:t,...s})}async delete(e,t){await this.client.send(`${this.collectionPath(t.collection)}/${encodeURIComponent(e)}`,{method:"DELETE",...t})}async list(e){return this.client.send(this.collectionPath(e.collection),{method:"GET",query:{page:e.page,perPage:e.perPage,...e.query??{}},...e})}async query(e,t){return this.client.send(`${this.collectionPath(t.collection)}/documents/query`,{method:"POST",body:e,...t})}}class CacheService extends BaseService{async list(e){e=Object.assign({method:"GET"},e);const t=await this.client.send("/api/cache",e);return t?.items??[]}async create(e,t){return t=Object.assign({method:"POST",body:e},t),this.client.send("/api/cache",t)}async update(e,t,s){return s=Object.assign({method:"PATCH",body:t},s),this.client.send(`/api/cache/${encodeURIComponent(e)}`,s)}async delete(e,t){return t=Object.assign({method:"DELETE"},t),await this.client.send(`/api/cache/${encodeURIComponent(e)}`,t),!0}async setEntry(e,t,s,n,i){const r={value:s};return"number"==typeof n&&(r.ttlSeconds=n),i=Object.assign({method:"PUT",body:r},i),this.client.send(`/api/cache/${encodeURIComponent(e)}/entries/${encodeURIComponent(t)}`,i)}async getEntry(e,t,s){return s=Object.assign({method:"GET"},s),this.client.send(`/api/cache/${encodeURIComponent(e)}/entries/${encodeURIComponent(t)}`,s)}async renewEntry(e,t,s,n){const i={};return"number"==typeof s&&(i.ttlSeconds=s),n=Object.assign({method:"PATCH",body:i},n),this.client.send(`/api/cache/${encodeURIComponent(e)}/entries/${encodeURIComponent(t)}`,n)}async deleteEntry(e,t,s){return s=Object.assign({method:"DELETE"},s),await this.client.send(`/api/cache/${encodeURIComponent(e)}/entries/${encodeURIComponent(t)}`,s),!0}}class LangChaingoService extends BaseService{basePath(){return"/api/langchaingo"}async completions(e,t={}){return this.client.send(`${this.basePath()}/completions`,{method:"POST",body:e,...t})}async rag(e,t={}){return this.client.send(`${this.basePath()}/rag`,{method:"POST",body:e,...t})}async queryDocuments(e,t={}){return this.client.send(`${this.basePath()}/documents/query`,{method:"POST",body:e,...t})}async sql(e,t={}){return this.client.send(`${this.basePath()}/sql`,{method:"POST",body:e,...t})}}class GraphQLService extends BaseService{async query(e,t,s){const{operationName:n,variables:i,...r}=s||{};return this.client.send("/api/graphql",{...r,method:r.method||"POST",body:{query:e,operationName:n,variables:t??i??{}}})}}class PubSubService extends BaseService{constructor(e){super(e),this.socket=null,this.pendingConnects=[],this.pendingAcks=new Map,this.subscriptions={},this.reconnectAttempts=0,this.manualClose=!1,this.maxConnectTimeout=15e3,this.ackTimeoutMs=1e4,this.predefinedReconnectIntervals=[200,300,500,1e3,1200,1500,2e3],this.maxReconnectAttempts=1/0}get isConnected(){return!!this.socket&&this.socket.readyState===WebSocket.OPEN}async publish(e,t){if(!e)throw new Error("topic must be set.");await this.ensureSocket();const s=this.nextRequestId(),n=this.waitForAck(s,t=>({id:t?.id,topic:t?.topic||e,created:t?.created}));return await this.sendEnvelope({type:"publish",topic:e,data:t,requestId:s}),n}async subscribe(e,t){if(!e)throw new Error("topic must be set.");let s=!1;if(this.subscriptions[e]||(this.subscriptions[e]=new Set,s=!0),this.subscriptions[e].add(t),await this.ensureSocket(),s){const t=this.nextRequestId(),s=this.waitForAck(t).catch(()=>{});await this.sendEnvelope({type:"subscribe",topic:e,requestId:t}),await s}return async()=>{this.subscriptions[e]?.delete(t),0===this.subscriptions[e]?.size&&(delete this.subscriptions[e],await this.sendUnsubscribe(e)),this.hasSubscriptions()||this.disconnect()}}async unsubscribe(e){e?(delete this.subscriptions[e],await this.sendUnsubscribe(e)):(this.subscriptions={},this.socket&&this.socket.readyState===WebSocket.OPEN&&await this.sendEnvelope({type:"unsubscribe"}),this.disconnect())}disconnect(){this.manualClose=!0,this.rejectAllPending(new Error("pubsub connection closed")),this.closeSocket(),this.pendingConnects=[]}hasSubscriptions(){return Object.keys(this.subscriptions).length>0}buildWebSocketURL(){const e=this.client.buildURL("/api/pubsub");let t;try{t=new URL(e,"undefined"!=typeof window?window.location.href:"http://localhost")}catch{t=new URL("http://localhost")}const s=this.client.authStore?.token;return s&&t.searchParams.set("token",s),"https:"===t.protocol?t.protocol="wss:":"http:"===t.protocol?t.protocol="ws:":t.protocol&&":"!==t.protocol||(t.protocol="ws:"),t.toString()}nextRequestId(){return Math.random().toString(36).substring(2)+Date.now().toString(36)}async ensureSocket(){if(!this.isConnected)return new Promise((e,t)=>{this.pendingConnects.push({resolve:e,reject:t}),this.pendingConnects.length>1||this.initConnect()})}initConnect(){let e;this.closeSocket(!0),this.manualClose=!1;try{e=this.buildWebSocketURL()}catch(e){return void this.connectErrorHandler(e)}if("undefined"!=typeof WebSocket){try{this.socket=new WebSocket(e)}catch(e){return void this.connectErrorHandler(e)}clearTimeout(this.connectTimeoutId),this.connectTimeoutId=setTimeout(()=>{this.connectErrorHandler(new Error("WebSocket connect took too long."))},this.maxConnectTimeout),this.socket.onmessage=e=>this.handleMessage(e.data),this.socket.onerror=()=>{this.connectErrorHandler(new ClientResponseError("WebSocket connection failed."))},this.socket.onclose=()=>{this.handleClose()}}else this.connectErrorHandler(new Error("WebSocket is not available in this runtime environment."))}handleMessage(e){if(clearTimeout(this.connectTimeoutId),"string"!=typeof e)return;let t=null;try{t=JSON.parse(e)}catch{return}switch(t?.type){case"ready":this.handleConnected();break;case"message":{const e=t.topic||"",s=this.subscriptions[e];if(!s)return;const n={id:t.id,topic:e,created:t.created,data:t.data};s.forEach(e=>{try{e(n)}catch(e){}});break}case"published":case"subscribed":case"unsubscribed":case"pong":this.resolvePending(t.requestId,t);break;case"error":{const e=new Error(t.message||"pubsub error");t.requestId&&this.rejectPending(t.requestId,e);break}}}handleConnected(){const e=this.reconnectAttempts>0;this.reconnectAttempts=0,clearTimeout(this.reconnectTimeoutId),clearTimeout(this.connectTimeoutId);for(let e of this.pendingConnects)e.resolve();this.pendingConnects=[],e&&Object.keys(this.subscriptions).forEach(e=>{const t=this.nextRequestId();this.sendEnvelope({type:"subscribe",topic:e,requestId:t})})}handleClose(){if(this.socket=null,this.manualClose)return;if(this.rejectAllPending(new Error("pubsub connection closed")),!this.hasSubscriptions())return void(this.pendingConnects=[]);const e=this.predefinedReconnectIntervals[this.reconnectAttempts]||this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length-1];this.reconnectAttempts<=this.maxReconnectAttempts&&(this.reconnectAttempts++,clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=setTimeout(()=>this.initConnect(),e))}async sendEnvelope(e){if(this.socket&&this.socket.readyState===WebSocket.OPEN||await this.ensureSocket(),!this.socket)throw new Error("Unable to send websocket message - socket not initialized.");this.socket.send(JSON.stringify(e))}async sendUnsubscribe(e){if(!this.socket)return;const t=this.nextRequestId(),s=this.waitForAck(t).catch(()=>{});await this.sendEnvelope({type:"unsubscribe",topic:e,requestId:t}),await s}connectErrorHandler(e){if(clearTimeout(this.connectTimeoutId),this.reconnectAttempts>this.maxReconnectAttempts||this.manualClose){for(let t of this.pendingConnects)t.reject(new ClientResponseError(e));return this.pendingConnects=[],void this.closeSocket()}this.closeSocket(!0);const t=this.predefinedReconnectIntervals[this.reconnectAttempts]||this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length-1];this.reconnectAttempts++,clearTimeout(this.reconnectTimeoutId),this.reconnectTimeoutId=setTimeout(()=>this.initConnect(),t)}closeSocket(e=!1){if(this.socket)try{this.socket.onclose=null,this.socket.onerror=null,this.socket.onmessage=null,this.socket.close()}catch(e){}this.socket=null,clearTimeout(this.connectTimeoutId),clearTimeout(this.reconnectTimeoutId),e||(this.subscriptions={},this.pendingAcks.clear())}waitForAck(e,t){return new Promise((s,n)=>{const i=setTimeout(()=>{this.pendingAcks.delete(e),n(new Error("Timed out waiting for pubsub response."))},this.ackTimeoutMs);this.pendingAcks.set(e,{resolve:n=>{clearTimeout(i),this.pendingAcks.delete(e),s(t?t(n):n)},reject:t=>{clearTimeout(i),this.pendingAcks.delete(e),n(t)}})})}resolvePending(e,t){const s=e?this.pendingAcks.get(e):null;s?.resolve(t)}rejectPending(e,t){const s=e?this.pendingAcks.get(e):null;s?.reject(t)}rejectAllPending(e){for(let t of this.pendingAcks.values())t.reject(e);this.pendingAcks.clear();for(let t of this.pendingConnects)t.reject(e);this.pendingConnects=[]}}class Client{get baseUrl(){return this.baseURL}set baseUrl(e){this.baseURL=e}constructor(e="/",t,s="en-US"){this.cancelControllers={},this.recordServices={},this.enableAutoCancellation=!0,this.baseURL=e,this.lang=s,t?this.authStore=t:"undefined"!=typeof window&&window.Deno?this.authStore=new BaseAuthStore:this.authStore=new LocalAuthStore,this.collections=new CollectionService(this),this.files=new FileService(this),this.logs=new LogService(this),this.settings=new SettingsService(this),this.realtime=new RealtimeService(this),this.pubsub=new PubSubService(this),this.health=new HealthService(this),this.backups=new BackupService(this),this.crons=new CronService(this),this.vectors=new VectorService(this),this.llmDocuments=new LLMDocumentService(this),this.langchaingo=new LangChaingoService(this),this.caches=new CacheService(this),this.graphql=new GraphQLService(this)}get admins(){return this.collection("_superusers")}createBatch(){return new BatchService(this)}collection(e){return this.recordServices[e]||(this.recordServices[e]=new RecordService(this,e)),this.recordServices[e]}autoCancellation(e){return this.enableAutoCancellation=!!e,this}cancelRequest(e){return this.cancelControllers[e]&&(this.cancelControllers[e].abort(),delete this.cancelControllers[e]),this}cancelAllRequests(){for(let e in this.cancelControllers)this.cancelControllers[e].abort();return this.cancelControllers={},this}filter(e,t){if(!t)return e;for(let s in t){let n=t[s];switch(typeof n){case"boolean":case"number":n=""+n;break;case"string":n="'"+n.replace(/'/g,"\\'")+"'";break;default:n=null===n?"null":n instanceof Date?"'"+n.toISOString().replace("T"," ")+"'":"'"+JSON.stringify(n).replace(/'/g,"\\'")+"'"}e=e.replaceAll("{:"+s+"}",n)}return e}getFileUrl(e,t,s={}){return console.warn("Please replace pb.getFileUrl() with pb.files.getURL()"),this.files.getURL(e,t,s)}buildUrl(e){return console.warn("Please replace pb.buildUrl() with pb.buildURL()"),this.buildURL(e)}buildURL(e){let t=this.baseURL;return"undefined"==typeof window||!window.location||t.startsWith("https://")||t.startsWith("http://")||(t=window.location.origin?.endsWith("/")?window.location.origin.substring(0,window.location.origin.length-1):window.location.origin||"",this.baseURL.startsWith("/")||(t+=window.location.pathname||"/",t+=t.endsWith("/")?"":"/"),t+=this.baseURL),e&&(t+=t.endsWith("/")?"":"/",t+=e.startsWith("/")?e.substring(1):e),t}async send(e,t){t=this.initSendOptions(e,t);let s=this.buildURL(e);if(this.beforeSend){const e=Object.assign({},await this.beforeSend(s,t));void 0!==e.url||void 0!==e.options?(s=e.url||s,t=e.options||t):Object.keys(e).length&&(t=e,console?.warn&&console.warn("Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`."))}if(void 0!==t.query){const e=serializeQueryParams(t.query);e&&(s+=(s.includes("?")?"&":"?")+e),delete t.query}"application/json"==this.getHeader(t.headers,"Content-Type")&&t.body&&"string"!=typeof t.body&&(t.body=JSON.stringify(t.body));return(t.fetch||fetch)(s,t).then(async e=>{let s={};try{s=await e.json()}catch(e){}if(this.afterSend&&(s=await this.afterSend(e,s,t)),e.status>=400)throw new ClientResponseError({url:e.url,status:e.status,data:s});return s}).catch(e=>{throw new ClientResponseError(e)})}initSendOptions(e,t){if((t=Object.assign({method:"GET"},t)).body=function convertToFormDataIfNeeded(e){if("undefined"==typeof FormData||void 0===e||"object"!=typeof e||null===e||isFormData(e)||!hasFileField(e))return e;const t=new FormData;for(const s in e){const n=e[s];if(void 0!==n)if("object"!=typeof n||hasFileField({data:n})){const e=Array.isArray(n)?n:[n];for(let n of e)t.append(s,n)}else{let e={};e[s]=n,t.append("@jsonPayload",JSON.stringify(e))}}return t}(t.body),normalizeUnknownQueryParams(t),t.query=Object.assign({},t.params,t.query),void 0===t.requestKey&&(!1===t.$autoCancel||!1===t.query.$autoCancel?t.requestKey=null:(t.$cancelKey||t.query.$cancelKey)&&(t.requestKey=t.$cancelKey||t.query.$cancelKey)),delete t.$autoCancel,delete t.query.$autoCancel,delete t.$cancelKey,delete t.query.$cancelKey,null!==this.getHeader(t.headers,"Content-Type")||isFormData(t.body)||(t.headers=Object.assign({},t.headers,{"Content-Type":"application/json"})),null===this.getHeader(t.headers,"Accept-Language")&&(t.headers=Object.assign({},t.headers,{"Accept-Language":this.lang})),this.authStore.token&&null===this.getHeader(t.headers,"Authorization")&&(t.headers=Object.assign({},t.headers,{Authorization:this.authStore.token})),this.enableAutoCancellation&&null!==t.requestKey){const s=t.requestKey||(t.method||"GET")+e;delete t.requestKey,this.cancelRequest(s);const n=new AbortController;this.cancelControllers[s]=n,t.signal=n.signal}return t}getHeader(e,t){e=e||{},t=t.toLowerCase();for(let s in e)if(s.toLowerCase()==t)return e[s];return null}}class AsyncAuthStore extends BaseAuthStore{constructor(e){super(),this.queue=[],this.saveFunc=e.save,this.clearFunc=e.clear,this._enqueue(()=>this._loadInitial(e.initial))}save(e,t){super.save(e,t);let s="";try{s=JSON.stringify({token:e,record:t})}catch(e){console.warn("AsyncAuthStore: failed to stringify the new state")}this._enqueue(()=>this.saveFunc(s))}clear(){super.clear(),this.clearFunc?this._enqueue(()=>this.clearFunc()):this._enqueue(()=>this.saveFunc(""))}async _loadInitial(e){try{if(e=await e){let t;"string"==typeof e?t=JSON.parse(e)||{}:"object"==typeof e&&(t=e),this.save(t.token||"",t.record||t.model||null)}}catch(e){}}_enqueue(e){this.queue.push(e),1==this.queue.length&&this._dequeue()}_dequeue(){this.queue.length&&this.queue[0]().finally(()=>{this.queue.shift(),this.queue.length&&this._dequeue()})}}export{AsyncAuthStore,BaseAuthStore,BatchService,CacheService,ClientResponseError,CollectionService,CrudService,GraphQLService,HealthService,LLMDocumentService,LangChaingoService,LocalAuthStore,LogService,PubSubService,RealtimeService,RecordService,SubBatchService,VectorService,cookieParse,cookieSerialize,Client as default,getTokenPayload,isTokenExpired,normalizeUnknownQueryParams,serializeQueryParams};
//# sourceMappingURL=bosbase.es.mjs.map
