{"version":3,"file":"bosbase.es.js","sources":["../src/ClientResponseError.ts","../src/tools/cookie.ts","../src/tools/jwt.ts","../src/stores/BaseAuthStore.ts","../src/stores/LocalAuthStore.ts","../src/services/BaseService.ts","../src/services/SettingsService.ts","../src/tools/options.ts","../src/services/RealtimeService.ts","../src/services/CrudService.ts","../src/tools/legacy.ts","../src/tools/refresh.ts","../src/services/RecordService.ts","../src/services/CollectionService.ts","../src/services/LogService.ts","../src/services/HealthService.ts","../src/services/FileService.ts","../src/services/BackupService.ts","../src/services/CronService.ts","../src/tools/formdata.ts","../src/services/BatchService.ts","../src/services/VectorService.ts","../src/services/LLMDocumentService.ts","../src/services/CacheService.ts","../src/services/LangChaingoService.ts","../src/services/GraphQLService.ts","../src/services/PubSubService.ts","../src/Client.ts","../src/stores/AsyncAuthStore.ts"],"sourcesContent":["/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport class ClientResponseError extends Error {\n    url: string = \"\";\n    status: number = 0;\n    response: { [key: string]: any } = {};\n    isAbort: boolean = false;\n    originalError: any = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === \"object\") {\n            this.url = typeof errData.url === \"string\" ? errData.url : \"\";\n            this.status = typeof errData.status === \"number\" ? errData.status : 0;\n            this.isAbort = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === \"object\") {\n                this.response = errData.response;\n            } else if (errData.data !== null && typeof errData.data === \"object\") {\n                this.response = errData.data;\n            } else {\n                this.response = {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== \"undefined\" && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message =\n                    \"The request was autocancelled. You can find more info in https://github.com/bosbase/js-sdk#auto-cancellation.\";\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message =\n                    \"Failed to connect to the BosBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/bosbase/js-sdk/issues/21).\";\n            } else {\n                this.message = \"Something went wrong.\";\n            }\n        }\n\n        // set this.cause so that JS debugging tools can automatically connect\n        // the dots between the original error and the wrapped one\n        this.cause = this.originalError;\n    }\n\n    /**\n     * Alias for `this.response` for backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions {\n    decode?: (val: string) => string;\n}\n\n/**\n * Parses the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any } {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== \"string\") {\n        return result;\n    }\n\n    const opt = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf(\"=\", index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(\";\", index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n}\n\nexport interface SerializeOptions {\n    encode?: (val: string | number | boolean) => string;\n    maxAge?: number;\n    domain?: string;\n    path?: string;\n    expires?: Date;\n    httpOnly?: boolean;\n    secure?: boolean;\n    priority?: string;\n    sameSite?: boolean | string;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(\n    name: string,\n    val: string,\n    options?: SerializeOptions,\n): string {\n    const opt = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n    }\n\n    let result = name + \"=\" + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError(\"option maxAge is invalid\");\n        }\n\n        result += \"; Max-Age=\" + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n\n        result += \"; Domain=\" + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n\n        result += \"; Path=\" + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError(\"option expires is invalid\");\n        }\n\n        result += \"; Expires=\" + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += \"; HttpOnly\";\n    }\n\n    if (opt.secure) {\n        result += \"; Secure\";\n    }\n\n    if (opt.priority) {\n        const priority =\n            typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case \"low\":\n                result += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                result += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                result += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(\"option priority is invalid\");\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite =\n            typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                result += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                result += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                result += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n\n    return result;\n}\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf(\"%\") !== -1 ? decodeURIComponent(val) : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n","// @todo remove after https://github.com/reactwg/react-native-releases/issues/287\nconst isReactNative =\n    (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") ||\n    (typeof global !== \"undefined\" && (global as any).HermesInternal);\n\nlet atobPolyfill: Function;\nif (typeof atob === \"function\" && !isReactNative) {\n    atobPolyfill = atob;\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\n                \"'atob' failed: The string to be decoded is not correctly encoded.\",\n            );\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4)\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(\n                atobPolyfill(token.split(\".\")[1])\n                    .split(\"\")\n                    .map(function (c: string) {\n                        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                    })\n                    .join(\"\"),\n            );\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {}\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || payload.exp - expirationThreshold > Date.now() / 1000)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from \"@/tools/cookie\";\nimport { isTokenExpired, getTokenPayload } from \"@/tools/jwt\";\nimport { RecordModel } from \"@/tools/dtos\";\n\nexport type AuthRecord = RecordModel | null;\n\nexport type AuthModel = AuthRecord; // for backward compatibility\n\nexport type OnStoreChangeFunc = (token: string, record: AuthRecord) => void;\n\nconst defaultCookieKey = \"pb_auth\";\n\n/**\n * Base AuthStore class that stores the auth state in runtime memory (aka. only for the duration of the store instane).\n *\n * Usually you wouldn't use it directly and instead use the builtin LocalAuthStore, AsyncAuthStore\n * or extend it with your own custom implementation.\n */\nexport class BaseAuthStore {\n    protected baseToken: string = \"\";\n    protected baseModel: AuthRecord = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get record(): AuthRecord {\n        return this.baseModel;\n    }\n\n    /**\n     * @deprecated use `record` instead.\n     */\n    get model(): AuthRecord {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Loosely checks whether the currently loaded store state is for superuser.\n     *\n     * Alternatively you can also compare directly `pb.authStore.record?.collectionName`.\n     */\n    get isSuperuser(): boolean {\n        let payload = getTokenPayload(this.token);\n\n        return (\n            payload.type == \"auth\" &&\n            (this.record?.collectionName == \"_superusers\" ||\n                // fallback in case the record field is not populated and assuming\n                // that the collection crc32 checksum id wasn't manually changed\n                (!this.record?.collectionName &&\n                    payload.collectionId == \"pbc_3142635823\"))\n        );\n    }\n\n    /**\n     * @deprecated use `isSuperuser` instead or simply check the record.collectionName property.\n     */\n    get isAdmin(): boolean {\n        console.warn(\n            \"Please replace pb.authStore.isAdmin with pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\",\n        );\n        return this.isSuperuser;\n    }\n\n    /**\n     * @deprecated use `!isSuperuser` instead or simply check the record.collectionName property.\n     */\n    get isAuthRecord(): boolean {\n        console.warn(\n            \"Please replace pb.authStore.isAuthRecord with !pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\",\n        );\n        return getTokenPayload(this.token).type == \"auth\" && !this.isSuperuser;\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, record?: AuthRecord): void {\n        this.baseToken = token || \"\";\n        this.baseModel = record || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = \"\";\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * BosBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || \"\")[key] || \"\";\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== \"object\" || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || \"\", data.record || data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure: true,\n            sameSite: true,\n            httpOnly: true,\n            path: \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date(\"1970-01-01\");\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            record: this.record ? JSON.parse(JSON.stringify(this.record)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength =\n            typeof Blob !== \"undefined\" ? new Blob([result]).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.record && resultLength > 4096) {\n            rawData.record = { id: rawData.record?.id, email: rawData.record?.email };\n            const extraProps = [\"collectionId\", \"collectionName\", \"verified\"];\n            for (const prop in this.record) {\n                if (extraProps.includes(prop)) {\n                    rawData.record[prop] = this.record[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.record);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i]; // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        };\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.record);\n        }\n    }\n}\n","import { BaseAuthStore, AuthRecord } from \"@/stores/BaseAuthStore\";\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (e.g. in node env).\n */\nexport class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string;\n\n    constructor(storageKey = \"bosbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n\n        this._bindStorageEvent();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || \"\";\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get record(): AuthRecord {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.record || data.model || null;\n    }\n\n    /**\n     * @deprecated use `record` instead.\n     */\n    get model(): AuthRecord {\n        return this.record;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, record?: AuthRecord) {\n        this._storageSet(this.storageKey, {\n            token: token,\n            record: record,\n        });\n\n        super.save(token, record);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || \"\";\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) {\n                // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== \"string\") {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n\n    /**\n     * Updates the current store state on localStorage change.\n     */\n    private _bindStorageEvent() {\n        if (\n            typeof window === \"undefined\" ||\n            !window?.localStorage ||\n            !window.addEventListener\n        ) {\n            return;\n        }\n\n        window.addEventListener(\"storage\", (e) => {\n            if (e.key != this.storageKey) {\n                return;\n            }\n\n            const data = this._storageGet(this.storageKey) || {};\n\n            super.save(data.token || \"\", data.record || data.model || null);\n        });\n    }\n}\n","import Client from \"@/Client\";\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport abstract class BaseService {\n    readonly client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getAll(options?: CommonOptions): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Bulk updates app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     *\n     * @throws {ClientResponseError}\n     */\n    async testS3(\n        filesystem: string = \"storage\",\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    filesystem: filesystem,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/s3\", options).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     *\n     * @throws {ClientResponseError}\n     */\n    async testEmail(\n        collectionIdOrName: string,\n        toEmail: string,\n        emailTemplate: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    email: toEmail,\n                    template: emailTemplate,\n                    collection: collectionIdOrName,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/email\", options).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     *\n     * @throws {ClientResponseError}\n     */\n    async generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<appleClientSecret> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    clientId,\n                    teamId,\n                    keyId,\n                    privateKey,\n                    duration,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/apple/generate-client-secret\", options);\n    }\n\n    // -------------------------------------------------------------------\n    // Settings Category Helpers\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets a specific settings category.\n     * \n     * @param category - The settings category name (meta, smtp, s3, backups, batch, rateLimits, trustedProxy, logs)\n     * @param options - Optional request options\n     * @returns The settings category object\n     * @throws {ClientResponseError}\n     */\n    async getCategory(category: string, options?: CommonOptions): Promise<any> {\n        const allSettings = await this.getAll(options);\n        return allSettings[category] || null;\n    }\n\n    /**\n     * Updates the Meta configuration (app name, URL, sender info, etc.).\n     * \n     * @param config - Meta configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateMeta(\n        config: {\n            appName?: string;\n            appURL?: string;\n            senderName?: string;\n            senderAddress?: string;\n            hideControls?: boolean;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ meta: config }, options);\n    }\n\n    // -------------------------------------------------------------------\n    // Application Configuration Helpers (Meta + TrustedProxy + RateLimits + Batch)\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets the current application configuration settings.\n     * \n     * This is a convenience method that returns all application configuration,\n     * matching what's shown on the application settings page (`/_/#/settings`):\n     * - Meta settings (app name, URL, hideControls)\n     * - TrustedProxy settings\n     * - RateLimits settings\n     * - Batch settings\n     * \n     * @param options - Optional request options\n     * @returns Object containing application configuration\n     * @throws {ClientResponseError}\n     */\n    async getApplicationSettings(options?: CommonOptions): Promise<{\n        meta?: {\n            appName?: string;\n            appURL?: string;\n            senderName?: string;\n            senderAddress?: string;\n            hideControls?: boolean;\n        };\n        trustedProxy?: {\n            headers?: Array<string>;\n            useLeftmostIP?: boolean;\n        };\n        rateLimits?: {\n            rules?: Array<any>;\n        };\n        batch?: {\n            enabled?: boolean;\n            maxRequests?: number;\n            interval?: number;\n        };\n    }> {\n        const allSettings = await this.getAll(options);\n        return {\n            meta: allSettings.meta,\n            trustedProxy: allSettings.trustedProxy,\n            rateLimits: allSettings.rateLimits,\n            batch: allSettings.batch,\n        };\n    }\n\n    /**\n     * Updates application configuration settings.\n     * \n     * This is a convenience method for managing all application configuration\n     * categories at once (meta, trustedProxy, rateLimits, batch).\n     * \n     * @param config - Application configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateApplicationSettings(\n        config: {\n            meta?: {\n                appName?: string;\n                appURL?: string;\n                senderName?: string;\n                senderAddress?: string;\n                hideControls?: boolean;\n            };\n            trustedProxy?: {\n                headers?: Array<string>;\n                useLeftmostIP?: boolean;\n            };\n            rateLimits?: {\n                rules?: Array<any>;\n            };\n            batch?: {\n                enabled?: boolean;\n                maxRequests?: number;\n                interval?: number;\n            };\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update(config, options);\n    }\n\n    /**\n     * Updates the SMTP email configuration.\n     * \n     * @param config - SMTP configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateSMTP(\n        config: {\n            enabled?: boolean;\n            host?: string;\n            port?: number;\n            username?: string;\n            password?: string;\n            authMethod?: string;\n            tls?: boolean;\n            localName?: string;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ smtp: config }, options);\n    }\n\n    // -------------------------------------------------------------------\n    // Mail-Specific Helpers (SMTP + Sender Info)\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets the current mail settings (both sender info from meta and SMTP configuration).\n     * \n     * This is a convenience method that returns both the sender information (meta)\n     * and SMTP configuration together, matching what's shown on the mail settings page.\n     * \n     * @param options - Optional request options\n     * @returns Object containing meta (senderName, senderAddress) and smtp configuration\n     * @throws {ClientResponseError}\n     */\n    async getMailSettings(options?: CommonOptions): Promise<{\n        meta?: {\n            senderName?: string;\n            senderAddress?: string;\n        };\n        smtp?: {\n            enabled?: boolean;\n            host?: string;\n            port?: number;\n            username?: string;\n            password?: string;\n            authMethod?: string;\n            tls?: boolean;\n            localName?: string;\n        };\n    }> {\n        const allSettings = await this.getAll(options);\n        return {\n            meta: {\n                senderName: allSettings.meta?.senderName,\n                senderAddress: allSettings.meta?.senderAddress,\n            },\n            smtp: allSettings.smtp,\n        };\n    }\n\n    /**\n     * Updates mail settings (both sender info and SMTP configuration).\n     * \n     * This is a convenience method that updates both the sender information (meta)\n     * and SMTP configuration in a single call, matching the mail settings page behavior.\n     * \n     * @param config - Mail settings updates (can include both sender info and SMTP config)\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateMailSettings(\n        config: {\n            senderName?: string;\n            senderAddress?: string;\n            smtp?: {\n                enabled?: boolean;\n                host?: string;\n                port?: number;\n                username?: string;\n                password?: string;\n                authMethod?: string;\n                tls?: boolean;\n                localName?: string;\n            };\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        const updateBody: { [key: string]: any } = {};\n\n        if (config.senderName !== undefined || config.senderAddress !== undefined) {\n            updateBody.meta = {};\n            if (config.senderName !== undefined) {\n                updateBody.meta.senderName = config.senderName;\n            }\n            if (config.senderAddress !== undefined) {\n                updateBody.meta.senderAddress = config.senderAddress;\n            }\n        }\n\n        if (config.smtp !== undefined) {\n            updateBody.smtp = config.smtp;\n        }\n\n        return this.update(updateBody, options);\n    }\n\n    /**\n     * Sends a test email with the configured SMTP settings.\n     * \n     * This is a convenience method for testing email configuration.\n     * The possible email template values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     * - otp\n     * - login-alert\n     * \n     * @param toEmail - Email address to send the test email to\n     * @param template - Email template to use (default: \"verification\")\n     * @param collectionIdOrName - Collection ID or name (default: \"_superusers\")\n     * @param options - Optional request options\n     * @returns true if email was sent successfully\n     * @throws {ClientResponseError}\n     */\n    async testMail(\n        toEmail: string,\n        template: string = \"verification\",\n        collectionIdOrName: string = \"_superusers\",\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        return this.testEmail(collectionIdOrName, toEmail, template, options);\n    }\n\n    /**\n     * Updates the S3 storage configuration.\n     * \n     * @param config - S3 configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateS3(\n        config: {\n            enabled?: boolean;\n            bucket?: string;\n            region?: string;\n            endpoint?: string;\n            accessKey?: string;\n            secret?: string;\n            forcePathStyle?: boolean;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ s3: config }, options);\n    }\n\n    // -------------------------------------------------------------------\n    // Storage-Specific Helpers (S3 File Storage)\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets the current S3 storage configuration.\n     * \n     * This is a convenience method specifically for file storage S3 configuration,\n     * equivalent to calling getCategory(\"s3\").\n     * \n     * @param options - Optional request options\n     * @returns S3 storage configuration object\n     * @throws {ClientResponseError}\n     */\n    async getStorageS3(options?: CommonOptions): Promise<any> {\n        return this.getCategory(\"s3\", options);\n    }\n\n    /**\n     * Updates the S3 storage configuration for file storage.\n     * \n     * This is a convenience method specifically for file storage S3 configuration,\n     * equivalent to calling updateS3().\n     * \n     * @param config - S3 storage configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateStorageS3(\n        config: {\n            enabled?: boolean;\n            bucket?: string;\n            region?: string;\n            endpoint?: string;\n            accessKey?: string;\n            secret?: string;\n            forcePathStyle?: boolean;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateS3(config, options);\n    }\n\n    /**\n     * Tests the S3 storage connection for file storage.\n     * \n     * This is a convenience method that tests the \"storage\" filesystem,\n     * equivalent to calling testS3(\"storage\").\n     * \n     * @param options - Optional request options\n     * @returns true if connection test succeeds\n     * @throws {ClientResponseError}\n     */\n    async testStorageS3(options?: CommonOptions): Promise<boolean> {\n        return this.testS3(\"storage\", options);\n    }\n\n    /**\n     * Updates the Backups configuration (scheduling and S3 storage).\n     * \n     * @param config - Backups configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateBackups(\n        config: {\n            cron?: string;\n            cronMaxKeep?: number;\n            s3?: {\n                enabled?: boolean;\n                bucket?: string;\n                region?: string;\n                endpoint?: string;\n                accessKey?: string;\n                secret?: string;\n                forcePathStyle?: boolean;\n            };\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ backups: config }, options);\n    }\n\n    // -------------------------------------------------------------------\n    // Backup-Specific Helpers (Auto-Backup + S3 Storage)\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets the current backup settings (auto-backup schedule and S3 storage configuration).\n     * \n     * This is a convenience method that returns backup configuration,\n     * matching what's shown on the backups settings page.\n     * \n     * @param options - Optional request options\n     * @returns Object containing backup configuration (cron, cronMaxKeep, s3)\n     * @throws {ClientResponseError}\n     */\n    async getBackupSettings(options?: CommonOptions): Promise<{\n        cron?: string;\n        cronMaxKeep?: number;\n        s3?: {\n            enabled?: boolean;\n            bucket?: string;\n            region?: string;\n            endpoint?: string;\n            accessKey?: string;\n            secret?: string;\n            forcePathStyle?: boolean;\n        };\n    }> {\n        const allSettings = await this.getAll(options);\n        return allSettings.backups || {};\n    }\n\n    /**\n     * Updates backup settings (auto-backup schedule and S3 storage configuration).\n     * \n     * This is a convenience method for managing backup configuration:\n     * - Auto-backup cron schedule (leave empty to disable)\n     * - Maximum number of backups to keep\n     * - S3 storage configuration for backups\n     * \n     * @param config - Backup settings updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateBackupSettings(\n        config: {\n            cron?: string;\n            cronMaxKeep?: number;\n            s3?: {\n                enabled?: boolean;\n                bucket?: string;\n                region?: string;\n                endpoint?: string;\n                accessKey?: string;\n                secret?: string;\n                forcePathStyle?: boolean;\n            };\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateBackups(config, options);\n    }\n\n    /**\n     * Sets the auto-backup cron schedule.\n     * \n     * @param cron - Cron expression (e.g., \"0 0 * * *\" for daily). Use empty string to disable.\n     * @param cronMaxKeep - Maximum number of backups to keep (required if cron is set)\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async setAutoBackupSchedule(\n        cron: string,\n        cronMaxKeep?: number,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        const config: any = { cron: cron || \"\" };\n        if (cronMaxKeep !== undefined) {\n            config.cronMaxKeep = cronMaxKeep;\n        }\n        return this.updateBackups(config, options);\n    }\n\n    /**\n     * Disables auto-backup (removes cron schedule).\n     * \n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async disableAutoBackup(options?: CommonOptions): Promise<{ [key: string]: any }> {\n        return this.updateBackups({ cron: \"\" }, options);\n    }\n\n    /**\n     * Tests the S3 backups connection.\n     * \n     * This is a convenience method that tests the \"backups\" filesystem,\n     * equivalent to calling testS3(\"backups\").\n     * \n     * @param options - Optional request options\n     * @returns true if connection test succeeds\n     * @throws {ClientResponseError}\n     */\n    async testBackupsS3(options?: CommonOptions): Promise<boolean> {\n        return this.testS3(\"backups\", options);\n    }\n\n    /**\n     * Updates the Batch request configuration.\n     * \n     * @param config - Batch configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateBatch(\n        config: {\n            enabled?: boolean;\n            maxRequests?: number;\n            timeout?: number;\n            maxBodySize?: number;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ batch: config }, options);\n    }\n\n    /**\n     * Updates the Rate Limits configuration.\n     * \n     * @param config - Rate limits configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateRateLimits(\n        config: {\n            enabled?: boolean;\n            rules?: Array<{\n                label: string;\n                audience?: string;\n                duration: number;\n                maxRequests: number;\n            }>;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ rateLimits: config }, options);\n    }\n\n    /**\n     * Updates the Trusted Proxy configuration.\n     * \n     * @param config - Trusted proxy configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateTrustedProxy(\n        config: {\n            headers?: Array<string>;\n            useLeftmostIP?: boolean;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ trustedProxy: config }, options);\n    }\n\n    /**\n     * Updates the Logs configuration.\n     * \n     * @param config - Logs configuration updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateLogs(\n        config: {\n            maxDays?: number;\n            minLevel?: number;\n            logIP?: boolean;\n            logAuthId?: boolean;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.update({ logs: config }, options);\n    }\n\n    // -------------------------------------------------------------------\n    // Log-Specific Helpers\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets the current log settings configuration.\n     * \n     * This is a convenience method that returns log configuration,\n     * matching what's shown on the logs settings panel.\n     * \n     * @param options - Optional request options\n     * @returns Object containing log configuration (maxDays, minLevel, logIP, logAuthId)\n     * @throws {ClientResponseError}\n     */\n    async getLogSettings(options?: CommonOptions): Promise<{\n        maxDays?: number;\n        minLevel?: number;\n        logIP?: boolean;\n        logAuthId?: boolean;\n    }> {\n        const allSettings = await this.getAll(options);\n        return allSettings.logs || {};\n    }\n\n    /**\n     * Updates log settings configuration.\n     * \n     * This is a convenience method for managing log configuration:\n     * - Maximum days to retain logs\n     * - Minimum log level\n     * - Whether to log IP addresses\n     * - Whether to log authentication IDs\n     * \n     * @param config - Log settings updates\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async updateLogSettings(\n        config: {\n            maxDays?: number;\n            minLevel?: number;\n            logIP?: boolean;\n            logAuthId?: boolean;\n        },\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateLogs(config, options);\n    }\n\n    /**\n     * Sets the maximum number of days to retain logs.\n     * \n     * @param maxDays - Maximum days to retain logs (0 or greater)\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async setLogRetentionDays(\n        maxDays: number,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateLogs({ maxDays }, options);\n    }\n\n    /**\n     * Sets the minimum log level.\n     * \n     * Log levels:\n     * - Negative values: Debug/Info levels\n     * - 0: Default/Warning level\n     * - Positive values: Error levels\n     * \n     * Only logs at or above this level will be retained.\n     * \n     * @param minLevel - Minimum log level (-100 to 100)\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async setMinLogLevel(\n        minLevel: number,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateLogs({ minLevel }, options);\n    }\n\n    /**\n     * Enables or disables IP address logging.\n     * \n     * @param enabled - Whether to log IP addresses\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async setLogIPAddresses(\n        enabled: boolean,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateLogs({ logIP: enabled }, options);\n    }\n\n    /**\n     * Enables or disables authentication ID logging.\n     * \n     * @param enabled - Whether to log authentication IDs\n     * @param options - Optional request options\n     * @returns Updated settings\n     * @throws {ClientResponseError}\n     */\n    async setLogAuthIds(\n        enabled: boolean,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        return this.updateLogs({ logAuthId: enabled }, options);\n    }\n}\n","export interface SendOptions extends RequestInit {\n    // for backward compatibility and to minimize the verbosity,\n    // any top-level field that doesn't exist in RequestInit or the\n    // fields below will be treated as query parameter.\n    [key: string]: any;\n\n    /**\n     * Optional custom fetch function to use for sending the request.\n     */\n    fetch?: (url: RequestInfo | URL, config?: RequestInit) => Promise<Response>;\n\n    /**\n     * Custom headers to send with the requests.\n     */\n    headers?: { [key: string]: string };\n\n    /**\n     * The body of the request (serialized automatically for json requests).\n     */\n    body?: any;\n\n    /**\n     * Query parameters that will be appended to the request url.\n     */\n    query?: { [key: string]: any };\n\n    /**\n     * @deprecated use `query` instead\n     *\n     * for backward-compatibility `params` values are merged with `query`,\n     * but this option may get removed in the final v1 release\n     */\n    params?: { [key: string]: any };\n\n    /**\n     * The request identifier that can be used to cancel pending requests.\n     */\n    requestKey?: string | null;\n\n    /**\n     * @deprecated use `requestKey:string` instead\n     */\n    $cancelKey?: string;\n\n    /**\n     * @deprecated use `requestKey:null` instead\n     */\n    $autoCancel?: boolean;\n}\n\nexport interface CommonOptions extends SendOptions {\n    fields?: string;\n}\n\nexport interface ListOptions extends CommonOptions {\n    page?: number;\n    perPage?: number;\n    sort?: string;\n    filter?: string;\n    skipTotal?: boolean;\n}\n\nexport interface FullListOptions extends ListOptions {\n    batch?: number;\n}\n\nexport interface RecordOptions extends CommonOptions {\n    expand?: string;\n}\n\nexport interface RecordListOptions extends ListOptions, RecordOptions {}\n\nexport interface RecordFullListOptions extends FullListOptions, RecordOptions {}\n\nexport interface RecordSubscribeOptions extends SendOptions {\n    fields?: string;\n    filter?: string;\n    expand?: string;\n}\n\nexport interface LogStatsOptions extends CommonOptions {\n    filter?: string;\n}\n\nexport interface FileOptions extends CommonOptions {\n    thumb?: string;\n    download?: boolean;\n}\n\nexport interface AuthOptions extends CommonOptions {\n    /**\n     * If autoRefreshThreshold is set it will take care to auto refresh\n     * when necessary the auth data before each request to ensure that\n     * the auth state is always valid.\n     *\n     * The value must be in seconds, aka. the amount of seconds\n     * that will be subtracted from the current token `exp` claim in order\n     * to determine whether it is going to expire within the specified time threshold.\n     *\n     * For example, if you want to auto refresh the token if it is\n     * going to expire in the next 30mins (or already has expired),\n     * it can be set to `1800`\n     */\n    autoRefreshThreshold?: number;\n}\n\n// -------------------------------------------------------------------\n\n// list of known SendOptions keys (everything else is treated as query param)\nconst knownSendOptionsKeys = [\n    \"requestKey\",\n    \"$cancelKey\",\n    \"$autoCancel\",\n    \"fetch\",\n    \"headers\",\n    \"body\",\n    \"query\",\n    \"params\",\n    // ---,\n    \"cache\",\n    \"credentials\",\n    \"headers\",\n    \"integrity\",\n    \"keepalive\",\n    \"method\",\n    \"mode\",\n    \"redirect\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"signal\",\n    \"window\",\n];\n\n// modifies in place the provided options by moving unknown send options as query parameters.\nexport function normalizeUnknownQueryParams(options?: SendOptions): void {\n    if (!options) {\n        return;\n    }\n\n    options.query = options.query || {};\n    for (let key in options) {\n        if (knownSendOptionsKeys.includes(key)) {\n            continue;\n        }\n\n        options.query[key] = options[key];\n        delete options[key];\n    }\n}\n\nexport function serializeQueryParams(params: { [key: string]: any }): string {\n    const result: Array<string> = [];\n\n    for (const key in params) {\n        const encodedKey = encodeURIComponent(key);\n        const arrValue = Array.isArray(params[key]) ? params[key] : [params[key]];\n\n        for (let v of arrValue) {\n            v = prepareQueryParamValue(v);\n            if (v === null) {\n                continue;\n            }\n            result.push(encodedKey + \"=\" + v);\n        }\n    }\n\n    return result.join(\"&\");\n}\n\n// encodes and normalizes the provided query param value.\nfunction prepareQueryParamValue(value: any): null | string {\n    if (value === null || typeof value === \"undefined\") {\n        return null;\n    }\n\n    if (value instanceof Date) {\n        return encodeURIComponent(value.toISOString().replace(\"T\", \" \"));\n    }\n\n    if (typeof value === \"object\") {\n        return encodeURIComponent(JSON.stringify(value));\n    }\n\n    return encodeURIComponent(value);\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { SendOptions, normalizeUnknownQueryParams } from \"@/tools/options\";\n\ninterface promiseCallbacks {\n    resolve: Function;\n    reject: Function;\n}\n\ntype Subscriptions = { [key: string]: Array<EventListener> };\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: Subscriptions = {};\n    private lastSentSubscriptions: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * An optional hook that is invoked when the realtime client disconnects\n     * either when unsubscribing from all subscriptions or when the\n     * connection was interrupted or closed by the server.\n     *\n     * The received argument could be used to determine whether the disconnect\n     * is a result from unsubscribing (`activeSubscriptions.length == 0`)\n     * or because of network/server error (`activeSubscriptions.length > 0`).\n     *\n     * If you want to listen for the opposite, aka. when the client connection is established,\n     * subscribe to the `PB_CONNECT` event.\n     */\n    onDisconnect?: (activeSubscriptions: Array<string>) => void;\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(\n        topic: string,\n        callback: (data: any) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        let key = topic;\n\n        // serialize and append the topic options (if any)\n        if (options) {\n            options = Object.assign({}, options); // shallow copy\n            normalizeUnknownQueryParams(options);\n            const serialized =\n                \"options=\" +\n                encodeURIComponent(\n                    JSON.stringify({ query: options.query, headers: options.headers }),\n                );\n            key += (key.includes(\"?\") ? \"&\" : \"?\") + serialized;\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = e as MessageEvent;\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[key]) {\n            this.subscriptions[key] = [];\n        }\n        this.subscriptions[key].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[key].length === 1) {\n            // send the updated subscriptions (if it is the first for the key)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(key, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        let needToSubmit = false;\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all listeners related to the topic\n            const subs = this.getSubscriptionsByTopic(topic);\n            for (let key in subs) {\n                if (!this.hasSubscriptionListeners(key)) {\n                    continue; // already unsubscribed\n                }\n\n                for (let listener of this.subscriptions[key]) {\n                    this.eventSource?.removeEventListener(key, listener);\n                }\n                delete this.subscriptions[key];\n\n                // mark for subscriptions change submit if there are no other listeners\n                if (!needToSubmit) {\n                    needToSubmit = true;\n                }\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(keyPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let key in this.subscriptions) {\n            // \"?\" so that it can be used as end delimiter for the prefix\n            if (!(key + \"?\").startsWith(keyPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            delete this.subscriptions[key];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(\n        topic: string,\n        listener: EventListener,\n    ): Promise<void> {\n        let needToSubmit = false;\n\n        const subs = this.getSubscriptionsByTopic(topic);\n        for (let key in subs) {\n            if (\n                !Array.isArray(this.subscriptions[key]) ||\n                !this.subscriptions[key].length\n            ) {\n                continue; // already unsubscribed\n            }\n\n            let exist = false;\n            for (let i = this.subscriptions[key].length - 1; i >= 0; i--) {\n                if (this.subscriptions[key][i] !== listener) {\n                    continue;\n                }\n\n                exist = true; // has at least one matching listener\n                delete this.subscriptions[key][i]; // removes the function reference\n                this.subscriptions[key].splice(i, 1); // reindex the array\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            if (!exist) {\n                continue;\n            }\n\n            // remove the key from the subscriptions list if there are no other listeners\n            if (!this.subscriptions[key].length) {\n                delete this.subscriptions[key];\n            }\n\n            // mark for subscriptions change submit if there are no other listeners\n            if (!needToSubmit && !this.hasSubscriptionListeners(key)) {\n                needToSubmit = true;\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(keyToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified key\n        if (keyToCheck) {\n            return !!this.subscriptions[keyToCheck]?.length;\n        }\n\n        // check for at least one non-empty subscription\n        for (let key in this.subscriptions) {\n            if (!!this.subscriptions[key]?.length) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys();\n\n        return this.client\n            .send(\"/api/realtime\", {\n                method: \"POST\",\n                body: {\n                    clientId: this.clientId,\n                    subscriptions: this.lastSentSubscriptions,\n                },\n                requestKey: this.getSubscriptionsCancelKey(),\n            })\n            .catch((err) => {\n                if (err?.isAbort) {\n                    return; // silently ignore aborted pending requests\n                }\n                throw err;\n            });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getSubscriptionsByTopic(topic: string): Subscriptions {\n        const result: Subscriptions = {};\n\n        // \"?\" so that it can be used as end delimiter for the topic\n        topic = topic.includes(\"?\") ? topic : topic + \"?\";\n\n        for (let key in this.subscriptions) {\n            if ((key + \"?\").startsWith(topic)) {\n                result[key] = this.subscriptions[key];\n            }\n        }\n\n        return result;\n    }\n\n    private getNonEmptySubscriptionKeys(): Array<string> {\n        const result: Array<string> = [];\n\n        for (let key in this.subscriptions) {\n            if (this.subscriptions[key].length) {\n                result.push(key);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.addEventListener(key, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.removeEventListener(key, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0) {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        });\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildURL(\"/api/realtime\"));\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(\n                new Error(\"Failed to establish realtime connection.\"),\n            );\n        };\n\n        this.eventSource.addEventListener(\"PB_CONNECT\", (e) => {\n            const msgEvent = e as MessageEvent;\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n                .then(async () => {\n                    let retries = 3;\n                    while (this.hasUnsentSubscriptions() && retries > 0) {\n                        retries--;\n                        // resubscribe to ensure that the latest topics are submitted\n                        //\n                        // This is needed because missed topics could happen on reconnect\n                        // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                        // was made before the submit was able to complete.\n                        await this.submitSubscriptions();\n                    }\n                })\n                .then(() => {\n                    for (let p of this.pendingConnects) {\n                        p.resolve();\n                    }\n\n                    // reset connect meta\n                    this.pendingConnects = [];\n                    this.reconnectAttempts = 0;\n                    clearTimeout(this.reconnectTimeoutId);\n                    clearTimeout(this.connectTimeoutId);\n\n                    // propagate the PB_CONNECT event\n                    const connectSubs = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n                    for (let key in connectSubs) {\n                        for (let listener of connectSubs[key]) {\n                            listener(e);\n                        }\n                    }\n                })\n                .catch((err) => {\n                    this.clientId = \"\";\n                    this.connectErrorHandler(err);\n                });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionKeys();\n        if (latestTopics.length != this.lastSentSubscriptions.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentSubscriptions.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[\n                this.predefinedReconnectIntervals.length - 1\n            ];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        if (this.clientId && this.onDisconnect) {\n            this.onDisconnect(Object.keys(this.subscriptions));\n        }\n\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/bosbase/bosbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult } from \"@/tools/dtos\";\nimport { CommonOptions, ListOptions, FullListOptions } from \"@/tools/options\";\n\nexport abstract class CrudService<M> extends BaseService {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string;\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>;\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    async getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>;\n\n    async getFullList<T = M>(\n        batchOrqueryParams?: number | FullListOptions,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, options);\n        }\n\n        options = Object.assign({}, batchOrqueryParams, options);\n\n        let batch = 500;\n        if (options.batch) {\n            batch = options.batch;\n            delete options.batch;\n        }\n\n        return this._getFullList<T>(batch, options);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<T>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(this.baseCrudPath, options).then((responseData: any) => {\n            responseData.items =\n                responseData.items?.map((item: any) => {\n                    return this.decode<T>(item);\n                }) || [];\n\n            return responseData;\n        });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign(\n            {\n                requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + filter,\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                filter: filter,\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        return this.getList<T>(1, 1, options).then((result) => {\n            if (!result?.items?.length) {\n                throw new ClientResponseError({\n                    status: 404,\n                    response: {\n                        code: 404,\n                        message: \"The requested resource wasn't found.\",\n                        data: {},\n                    },\n                });\n            }\n\n            return result.items[0];\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildURL(this.baseCrudPath + \"/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required record id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath, options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(\n        batchSize = 500,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        options = options || {};\n        options.query = Object.assign(\n            {\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, options).then((list) => {\n                const castedList = list as any as ListResult<T>;\n                const items = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        };\n\n        return request(1);\n    }\n}\n","import { SendOptions } from \"@/tools/options\";\n\nexport function normalizeLegacyOptionsArgs(\n    legacyWarn: string,\n    baseOptions: SendOptions,\n    bodyOrOptions?: any,\n    query?: any,\n): SendOptions {\n    const hasBodyOrOptions = typeof bodyOrOptions !== \"undefined\";\n    const hasQuery = typeof query !== \"undefined\";\n\n    if (!hasQuery && !hasBodyOrOptions) {\n        return baseOptions;\n    }\n\n    if (hasQuery) {\n        console.warn(legacyWarn);\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\n\n        return baseOptions;\n    }\n\n    return Object.assign(baseOptions, bodyOrOptions);\n}\n","import Client from \"@/Client\";\nimport { isTokenExpired } from \"@/tools/jwt\";\n\n// reset previous auto refresh registrations\nexport function resetAutoRefresh(client: Client) {\n    (client as any)._resetAutoRefresh?.();\n}\n\nexport function registerAutoRefresh(\n    client: Client,\n    threshold: number,\n    refreshFunc: () => Promise<any>,\n    reauthenticateFunc: () => Promise<any>,\n) {\n    resetAutoRefresh(client);\n\n    const oldBeforeSend = client.beforeSend;\n    const oldModel = client.authStore.record;\n\n    // unset the auto refresh in case the auth store was cleared\n    // OR a new model was authenticated\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\n        if (\n            !newToken ||\n            model?.id != oldModel?.id ||\n            ((model?.collectionId || oldModel?.collectionId) &&\n                model?.collectionId != oldModel?.collectionId)\n        ) {\n            resetAutoRefresh(client);\n        }\n    });\n\n    // initialize a reset function and attach it dynamically to the client\n    (client as any)._resetAutoRefresh = function () {\n        unsubStoreChange();\n        client.beforeSend = oldBeforeSend;\n        delete (client as any)._resetAutoRefresh;\n    };\n\n    client.beforeSend = async (url, sendOptions) => {\n        const oldToken = client.authStore.token;\n\n        if (sendOptions.query?.autoRefresh) {\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n        }\n\n        let isValid = client.authStore.isValid;\n        if (\n            // is loosely valid\n            isValid &&\n            // but it is going to expire in the next \"threshold\" seconds\n            isTokenExpired(client.authStore.token, threshold)\n        ) {\n            try {\n                await refreshFunc();\n            } catch (_) {\n                isValid = false;\n            }\n        }\n\n        // still invalid -> reauthenticate\n        if (!isValid) {\n            await reauthenticateFunc();\n        }\n\n        // the request wasn't sent with a custom token\n        const headers = sendOptions.headers || {};\n        for (let key in headers) {\n            if (\n                key.toLowerCase() == \"authorization\" &&\n                // the request wasn't sent with a custom token\n                oldToken == headers[key] &&\n                client.authStore.token\n            ) {\n                // set the latest store token\n                headers[key] = client.authStore.token;\n                break;\n            }\n        }\n        sendOptions.headers = headers;\n\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n    };\n}\n","import Client from \"@/Client\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { RealtimeService, UnsubscribeFunc } from \"@/services/RealtimeService\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { CrudService } from \"@/services/CrudService\";\nimport { ListResult, RecordModel } from \"@/tools/dtos\";\nimport { normalizeLegacyOptionsArgs } from \"@/tools/legacy\";\nimport {\n    CommonOptions,\n    RecordFullListOptions,\n    RecordListOptions,\n    RecordOptions,\n    SendOptions,\n    RecordSubscribeOptions,\n} from \"@/tools/options\";\nimport { getTokenPayload } from \"@/tools/jwt\";\nimport { registerAutoRefresh, resetAutoRefresh } from \"@/tools/refresh\";\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    /**\n     * The signed BosBase auth record.\n     */\n    record: T;\n\n    /**\n     * The BosBase record auth token.\n     *\n     * If you are looking for the OAuth2 access and refresh tokens\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\n     */\n    token: string;\n\n    /**\n     * Auth meta data usually filled when OAuth2 is used.\n     */\n    meta?: { [key: string]: any };\n}\n\nexport interface AuthProviderInfo {\n    name: string;\n    displayName: string;\n    state: string;\n    authURL: string;\n    codeVerifier: string;\n    codeChallenge: string;\n    codeChallengeMethod: string;\n}\n\nexport interface AuthMethodsList {\n    mfa: {\n        enabled: boolean;\n        duration: number;\n    };\n    otp: {\n        enabled: boolean;\n        duration: number;\n    };\n    password: {\n        enabled: boolean;\n        identityFields: Array<string>;\n    };\n    oauth2: {\n        enabled: boolean;\n        providers: Array<AuthProviderInfo>;\n    };\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void | Promise<void>;\n\nexport interface OAuth2AuthConfig extends SendOptions {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: { [key: string]: any };\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the BosBase auth request (eg. fields, expand, etc.)\n    query?: RecordOptions;\n}\n\nexport interface OTPResponse {\n    otpId: string;\n}\n\nexport class RecordService<M = RecordModel> extends CrudService<M> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + \"/records\";\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    /**\n     * Returns whether the current service collection is superusers.\n     */\n    get isSuperusers(): boolean {\n        return (\n            this.collectionIdOrName == \"_superusers\" ||\n            this.collectionIdOrName == \"_pbc_2773867675\"\n        );\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = M>(\n        topic: string,\n        callback: (data: RecordSubscription<T>) => void,\n        options?: RecordSubscribeOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"Missing topic.\");\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        return this.client.realtime.subscribe(\n            this.collectionIdOrName + \"/\" + topic,\n            callback,\n            options,\n        );\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe from the specified topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(\n                this.collectionIdOrName + \"/\" + topic,\n            );\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(options?: RecordFullListOptions): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batch?: number,\n        options?: RecordListOptions,\n    ): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batchOrOptions?: number | RecordFullListOptions,\n        options?: RecordListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrOptions == \"number\") {\n            return super.getFullList<T>(batchOrOptions, options);\n        }\n\n        const params = Object.assign({}, batchOrOptions, options);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: RecordListOptions,\n    ): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, options);\n    }\n\n    /**\n     * Returns the total count of records matching the provided filter.\n     *\n     * This method is optimized to only return the count without fetching\n     * the actual records, making it more efficient when you only need\n     * to know the quantity of matching records.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getCount(filter?: string, options?: RecordListOptions): Promise<number> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                filter: filter,\n            },\n            options.query,\n        );\n\n        const response = await this.client.send<{ count: number }>(\n            this.baseCrudPath + \"/count\",\n            options,\n        );\n\n        return response.count;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getFirstListItem<T = M>(\n        filter: string,\n        options?: RecordListOptions,\n    ): Promise<T> {\n        return super.getFirstListItem<T>(filter, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getOne<T = M>(id: string, options?: RecordOptions): Promise<T> {\n        return super.getOne<T>(id, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.create<T>(bodyParams, options);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.record` matches with the updated id, then\n     * on success the `client.authStore.record` will be updated with the new response record fields.\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.record?.id === item?.id &&\n                (this.client.authStore.record?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.record?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                let authExpand = Object.assign({}, this.client.authStore.record.expand);\n                let authRecord = Object.assign({}, this.client.authStore.record, item);\n                if (authExpand) {\n                    // for now \"merge\" only top-level expand\n                    authRecord.expand = Object.assign(authExpand, item.expand);\n                }\n\n                this.client.authStore.save(this.client.authStore.token, authRecord);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.record` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.record?.id === id &&\n                (this.client.authStore.record?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.record?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = M>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record as any);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            record: record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n                // @todo remove after deleting the pre v0.23 API response fields\n                fields: \"mfa,otp,password,oauth2\",\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCollectionPath + \"/auth-methods\", options);\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    identity: usernameOrEmail,\n                    password: password,\n                },\n            },\n            options,\n        );\n\n        // note: consider to deprecate\n        let autoRefreshThreshold;\n        if (this.isSuperusers) {\n            autoRefreshThreshold = options.autoRefreshThreshold;\n            delete options.autoRefreshThreshold;\n            if (!options.autoRefresh) {\n                resetAutoRefresh(this.client);\n            }\n        }\n\n        let authData = await this.client.send(\n            this.baseCollectionPath + \"/auth-with-password\",\n            options,\n        );\n\n        authData = this.authResponse<T>(authData);\n\n        if (autoRefreshThreshold && this.isSuperusers) {\n            registerAutoRefresh(\n                this.client,\n                autoRefreshThreshold,\n                () => this.authRefresh({ autoRefresh: true }),\n                () =>\n                    this.authWithPassword<T>(\n                        usernameOrEmail,\n                        password,\n                        Object.assign({ autoRefresh: true }, options),\n                    ),\n            );\n        }\n\n        return authData;\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createdData, options?).\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                provider: provider,\n                code: code,\n                codeVerifier: codeVerifier,\n                redirectURL: redirectURL,\n                createData: createData,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-oauth2\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://bosbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        bodyParams?: { [key: string]: any },\n        queryParams?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * Note1: When creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     *\n     * Note2: Safari may block the default `urlCallback` popup because\n     * it doesn't allow `window.open` calls as part of an `async` click functions.\n     * To workaround this you can either change your click handler to not be marked as `async`\n     * OR manually call `window.open` before your `async` function and use the\n     * window reference in your own custom `urlCallback` (see https://github.com/bosbase/bosbase/discussions/2429#discussioncomment-5943061).\n     * For example:\n     * ```js\n     * <button id=\"btn\">Login with Gitlab</button>\n     * ...\n     * document.getElementById(\"btn\").addEventListener(\"click\", () => {\n     *     pb.collection(\"users\").authWithOAuth2({\n     *         provider: \"gitlab\",\n     *     }).then((authData) => {\n     *         console.log(authData)\n     *     }).catch((err) => {\n     *         console.log(err, err.originalError);\n     *     });\n     * })\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2<T = M>(\n        options: OAuth2AuthConfig,\n    ): Promise<RecordAuthResponse<T>>;\n\n    authWithOAuth2<T = M>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === \"string\") {\n            console.warn(\n                \"BosBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://bosbase.io/docs/authentication/#oauth2-integration.\",\n            );\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || \"\",\n                args?.[1] || \"\",\n                args?.[2] || \"\",\n                args?.[3] || \"\",\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        // open a new popup window in case config.urlCallback is not set\n        //\n        // note: it is opened before any async calls due to Safari restrictions\n        // (see https://github.com/bosbase/bosbase/discussions/2429#discussioncomment-5943061)\n        let eagerDefaultPopup: Window | null = null;\n        if (!config.urlCallback) {\n            eagerDefaultPopup = openBrowserPopup(undefined);\n        }\n\n        // initialize a one-off realtime service\n        const realtime = new RealtimeService(this.client);\n\n        function cleanup() {\n            eagerDefaultPopup?.close();\n            realtime.unsubscribe();\n        }\n\n        const requestKeyOptions: SendOptions = {};\n        const requestKey = config.requestKey;\n        if (requestKey) {\n            requestKeyOptions.requestKey = requestKey;\n        }\n\n        return this.listAuthMethods(requestKeyOptions)\n            .then((authMethods) => {\n                const provider = authMethods.oauth2.providers.find(\n                    (p) => p.name === config.provider,\n                );\n                if (!provider) {\n                    throw new ClientResponseError(\n                        new Error(`Missing or invalid provider \"${config.provider}\".`),\n                    );\n                }\n\n                const redirectURL = this.client.buildURL(\"/api/oauth2-redirect\");\n\n                // find the AbortController associated with the current request key (if any)\n                const cancelController = requestKey\n                    ? this.client[\"cancelControllers\"]?.[requestKey]\n                    : undefined;\n                if (cancelController) {\n                    cancelController.signal.onabort = () => {\n                        cleanup();\n                    };\n                }\n\n                return new Promise(async (resolve, reject) => {\n                    try {\n                        await realtime.subscribe(\"@oauth2\", async (e) => {\n                            const oldState = realtime.clientId;\n\n                            try {\n                                if (!e.state || oldState !== e.state) {\n                                    throw new Error(\"State parameters don't match.\");\n                                }\n\n                                if (e.error || !e.code) {\n                                    throw new Error(\n                                        \"OAuth2 redirect error or missing code: \" +\n                                            e.error,\n                                    );\n                                }\n\n                                // clear the non SendOptions props\n                                const options = Object.assign({}, config);\n                                delete options.provider;\n                                delete options.scopes;\n                                delete options.createData;\n                                delete options.urlCallback;\n\n                                // reset the cancelController listener as it will be triggered by the next api call\n                                if (cancelController?.signal?.onabort) {\n                                    cancelController.signal.onabort = null;\n                                }\n\n                                const authData = await this.authWithOAuth2Code<T>(\n                                    provider.name,\n                                    e.code,\n                                    provider.codeVerifier,\n                                    redirectURL,\n                                    config.createData,\n                                    options,\n                                );\n\n                                resolve(authData);\n                            } catch (err) {\n                                reject(new ClientResponseError(err));\n                            }\n\n                            cleanup();\n                        });\n\n                        const replacements: { [key: string]: any } = {\n                            state: realtime.clientId,\n                        };\n                        if (config.scopes?.length) {\n                            replacements[\"scope\"] = config.scopes.join(\" \");\n                        }\n\n                        const url = this._replaceQueryParams(\n                            provider.authURL + redirectURL,\n                            replacements,\n                        );\n\n                        let urlCallback =\n                            config.urlCallback ||\n                            function (url: string) {\n                                if (eagerDefaultPopup) {\n                                    eagerDefaultPopup.location.href = url;\n                                } else {\n                                    // it could have been blocked due to its empty initial url,\n                                    // try again...\n                                    eagerDefaultPopup = openBrowserPopup(url);\n                                }\n                            };\n\n                        await urlCallback(url);\n                    } catch (err) {\n                        cleanup();\n                        reject(new ClientResponseError(err));\n                    }\n                });\n            })\n            .catch((err) => {\n                cleanup();\n                throw err; // rethrow\n            }) as Promise<RecordAuthResponse<T>>;\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh<T = M>(options?: RecordOptions): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh<T = M>(body?: any, query?: any): Promise<RecordAuthResponse<T>>;\n\n    async authRefresh<T = M>(\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-refresh\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: passwordResetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestVerification(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestVerification(email, options?).\n     */\n    async requestVerification(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestVerification(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-verification\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     *\n     * If the current `client.authStore.record` matches with the auth record from the token,\n     * then on success the `client.authStore.record.verified` will be updated to `true`.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmVerification(\n        verificationToken: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmVerification(verificationToken, options?).\n     */\n    async confirmVerification(\n        verificationToken: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmVerification(\n        verificationToken: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: verificationToken,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-verification\", options)\n            .then(() => {\n                // on success manually update the current auth record verified state\n                const payload = getTokenPayload(verificationToken);\n                const model = this.client.authStore.record;\n                if (\n                    model &&\n                    !model.verified &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    model.verified = true;\n                    this.client.authStore.save(this.client.authStore.token, model);\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestEmailChange(newEmail, options?).\n     */\n    async requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestEmailChange(\n        newEmail: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                newEmail: newEmail,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-email-change\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     *\n     * If the current `client.authStore.record` matches with the auth record from the token,\n     * then on success the `client.authStore` will be cleared.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: emailChangeToken,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-email-change\", options)\n            .then(() => {\n                const payload = getTokenPayload(emailChangeToken);\n                const model = this.client.authStore.record;\n                if (\n                    model &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    this.client.authStore.clear();\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * @deprecated use collection(\"_externalAuths\").*\n     *\n     * Lists all linked external auth providers for the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listExternalAuths(\n        recordId: string,\n        options?: CommonOptions,\n    ): Promise<Array<RecordModel>> {\n        return this.client.collection(\"_externalAuths\").getFullList(\n            Object.assign({}, options, {\n                filter: this.client.filter(\"recordRef = {:id}\", { id: recordId }),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated use collection(\"_externalAuths\").*\n     *\n     * Unlink a single external auth provider from the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        const ea = await this.client.collection(\"_externalAuths\").getFirstListItem(\n            this.client.filter(\"recordRef = {:recordId} && provider = {:provider}\", {\n                recordId,\n                provider,\n            }),\n        );\n\n        return this.client\n            .collection(\"_externalAuths\")\n            .delete(ea.id, options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record OTP to the provided email.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestOTP(email: string, options?: CommonOptions): Promise<OTPResponse> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { email: email },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCollectionPath + \"/request-otp\", options);\n    }\n\n    /**\n     * Authenticate a single auth collection record via OTP.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOTP<T = M>(\n        otpId: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<RecordAuthResponse<T>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { otpId, password },\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-otp\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Impersonate authenticates with the specified recordId and\n     * returns a new client with the received auth token in a memory store.\n     *\n     * If `duration` is 0 the generated auth token will fallback\n     * to the default collection auth token duration.\n     *\n     * This action currently requires superusers privileges.\n     *\n     * @throws {ClientResponseError}\n     */\n    async impersonate(\n        recordId: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<Client> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { duration: duration },\n            },\n            options,\n        );\n        options.headers = options.headers || {};\n        if (!options.headers.Authorization) {\n            options.headers.Authorization = this.client.authStore.token;\n        }\n\n        // create a new client loaded with the impersonated auth state\n        // ---\n        const client = new Client(\n            this.client.baseURL,\n            new BaseAuthStore(),\n            this.client.lang,\n        );\n\n        const authData = await client.send(\n            this.baseCollectionPath + \"/impersonate/\" + encodeURIComponent(recordId),\n            options,\n        );\n\n        client.authStore.save(authData?.token, this.decode(authData?.record || {}));\n        // ---\n\n        return client;\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(\n        url: string,\n        replacements: { [key: string]: any } = {},\n    ): string {\n        let urlPath = url;\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: { [key: string]: string } = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue;\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g, \" \"))] =\n                decodeURIComponent((pair[1] || \"\").replace(/\\+/g, \" \"));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query +=\n                encodeURIComponent(key.replace(/%20/g, \"+\")) +\n                \"=\" +\n                encodeURIComponent(parsedParams[key].replace(/%20/g, \"+\"));\n        }\n\n        return query != \"\" ? urlPath + \"?\" + query : urlPath;\n    }\n}\n\nfunction openBrowserPopup(url?: string): Window | null {\n    if (typeof window === \"undefined\" || !window?.open) {\n        throw new ClientResponseError(\n            new Error(\n                `Not in a browser context - please pass a custom urlCallback function.`,\n            ),\n        );\n    }\n\n    let width = 1024;\n    let height = 768;\n\n    let windowWidth = window.innerWidth;\n    let windowHeight = window.innerHeight;\n\n    // normalize window size\n    width = width > windowWidth ? windowWidth : width;\n    height = height > windowHeight ? windowHeight : height;\n\n    let left = windowWidth / 2 - width / 2;\n    let top = windowHeight / 2 - height / 2;\n\n    // note: we don't use the noopener and noreferrer attributes since\n    // for some reason browser blocks such windows then url is undefined/blank\n    return window.open(\n        url,\n        \"popup_window\",\n        \"width=\" +\n            width +\n            \",height=\" +\n            height +\n            \",top=\" +\n            top +\n            \",left=\" +\n            left +\n            \",resizable,menubar=no\",\n    );\n}\n","import { CrudService } from \"@/services/CrudService\";\nimport {\n    CollectionModel,\n    CollectionField,\n    CollectionSchemaInfo,\n    SqlTableDefinition,\n    SqlTableImportResult,\n} from \"@/tools/dtos\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport class CollectionService extends CrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/collections\";\n    }\n\n    /**\n     * Deletes a collection (table) by its id or name.\n     * \n     * This is a convenience method that wraps the inherited `delete()` method\n     * to make collection deletion explicit.\n     * \n     * **Warning**: This operation is destructive and will delete the collection\n     * along with all its records and associated data.\n     * \n     * @param collectionIdOrName - Collection id or name to delete\n     * @param options - Optional request options\n     * @returns true if deletion succeeds\n     * @throws {ClientResponseError}\n     */\n    async deleteCollection(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        return this.delete(collectionIdOrName, options);\n    }\n\n    /**\n     * Returns type indexed map with scaffolded collection models\n     * populated with their default field values.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getScaffolds(\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: CollectionModel }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/meta/scaffolds\", options);\n    }\n\n    /**\n     * Creates a new collection from a scaffold template.\n     * \n     * This is a convenience method that fetches the scaffold for the specified type\n     * and creates a new collection with the given name, using the scaffold as a base.\n     * \n     * @param type - Collection type: \"base\", \"auth\", or \"view\"\n     * @param name - Collection name\n     * @param overrides - Optional properties to override in the scaffold\n     * @param options - Optional request options\n     * @returns Created collection model\n     * @throws {ClientResponseError}\n     */\n    async createFromScaffold(\n        type: \"base\" | \"auth\" | \"view\",\n        name: string,\n        overrides?: Partial<CollectionModel>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const scaffolds = await this.getScaffolds(options);\n        const scaffold = scaffolds[type];\n        \n        if (!scaffold) {\n            throw new Error(`Scaffold for type \"${type}\" not found`);\n        }\n\n        // Create collection based on scaffold with overrides\n        const collection = {\n            ...scaffold,\n            name: name,\n            ...overrides,\n        } as CollectionModel;\n\n        return this.create(collection, options);\n    }\n\n    /**\n     * Creates a new base collection.\n     * \n     * Convenience method for creating a base collection type.\n     * \n     * @param name - Collection name\n     * @param overrides - Optional properties to override\n     * @param options - Optional request options\n     * @returns Created collection model\n     * @throws {ClientResponseError}\n     */\n    async createBase(\n        name: string,\n        overrides?: Partial<CollectionModel>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        return this.createFromScaffold(\"base\", name, overrides, options);\n    }\n\n    /**\n     * Creates a new auth collection.\n     * \n     * Convenience method for creating an auth collection type.\n     * \n     * @param name - Collection name\n     * @param overrides - Optional properties to override\n     * @param options - Optional request options\n     * @returns Created collection model\n     * @throws {ClientResponseError}\n     */\n    async createAuth(\n        name: string,\n        overrides?: Partial<CollectionModel>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        return this.createFromScaffold(\"auth\", name, overrides, options);\n    }\n\n    /**\n     * Creates a new view collection.\n     * \n     * Convenience method for creating a view collection type.\n     * \n     * @param name - Collection name\n     * @param viewQuery - SQL query for the view (required for view collections)\n     * @param overrides - Optional properties to override\n     * @param options - Optional request options\n     * @returns Created collection model\n     * @throws {ClientResponseError}\n     */\n    async createView(\n        name: string,\n        viewQuery?: string,\n        overrides?: Partial<CollectionModel>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const scaffoldOverrides: Partial<CollectionModel> = {\n            ...overrides,\n            ...(viewQuery ? { viewQuery } : {}),\n        };\n        return this.createFromScaffold(\"view\", name, scaffoldOverrides, options);\n    }\n\n    /**\n     * Deletes all records associated with the specified collection.\n     *\n     * @throws {ClientResponseError}\n     */\n    async truncate(collectionIdOrName: string, options?: CommonOptions): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\n                this.baseCrudPath +\n                    \"/\" +\n                    encodeURIComponent(collectionIdOrName) +\n                    \"/truncate\",\n                options,\n            )\n            .then(() => true);\n    }\n\n    /**\n     * Registers existing SQL tables and generates REST APIs for them.\n     *\n     * Only available to superusers.\n     *\n     * @param tables - List of table names to register\n     * @param options - Optional request options\n     * @returns Array of created collection models\n     * @throws {ClientResponseError}\n     */\n    async registerSqlTables(\n        tables: Array<string>,\n        options?: CommonOptions,\n    ): Promise<Array<CollectionModel>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    tables,\n                },\n            },\n            options,\n        );\n\n        return this.client.send<Array<CollectionModel>>(\n            this.baseCrudPath + \"/sql/tables\",\n            options,\n        );\n    }\n\n    /**\n     * Creates or registers SQL tables and maps them to collections.\n     *\n     * Tables with existing collections are skipped and returned in the `skipped` list.\n     * Optional `sql` statements are executed before registration (e.g. CREATE TABLE).\n     *\n     * Only available to superusers.\n     *\n     * @param tables - Table definitions (name + optional SQL)\n     * @param options - Optional request options\n     * @returns Object with created collections and skipped table names\n     * @throws {ClientResponseError}\n     */\n    async importSqlTables(\n        tables: Array<SqlTableDefinition>,\n        options?: CommonOptions,\n    ): Promise<SqlTableImportResult> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    tables,\n                },\n            },\n            options,\n        );\n\n        return this.client.send<SqlTableImportResult>(\n            this.baseCrudPath + \"/sql/import\",\n            options,\n        );\n    }\n\n    // -------------------------------------------------------------------\n    // Export/Import Helpers\n    // -------------------------------------------------------------------\n\n    /**\n     * Exports collections in a format suitable for import.\n     * \n     * This method fetches all collections and prepares them for export by:\n     * - Removing timestamps (created, updated)\n     * - Removing OAuth2 providers (for cleaner export)\n     * \n     * The returned collections can be saved as JSON and later imported.\n     * \n     * @param filterCollections - Optional function to filter which collections to export (by default exports all)\n     * @param options - Optional request options\n     * @returns Array of collection models ready for export\n     * @throws {ClientResponseError}\n     */\n    async exportCollections(\n        filterCollections?: (collection: CollectionModel) => boolean,\n        options?: CommonOptions,\n    ): Promise<Array<CollectionModel>> {\n        const collections = await this.getFullList<CollectionModel>(options);\n        \n        // Filter if a filter function is provided\n        let filtered = filterCollections \n            ? collections.filter(filterCollections)\n            : collections;\n\n        // Clean collections for export (matching UI behavior)\n        const cleaned = filtered.map((collection) => {\n            const cleaned = { ...collection };\n            \n            // Remove timestamps\n            delete (cleaned as any).created;\n            delete (cleaned as any).updated;\n            \n            // Remove OAuth2 providers\n            if ((cleaned as any).oauth2?.providers) {\n                delete (cleaned as any).oauth2.providers;\n            }\n            \n            return cleaned;\n        });\n\n        return cleaned;\n    }\n\n    /**\n     * Normalizes collections data for import.\n     * \n     * This helper method prepares collections data by:\n     * - Removing timestamps (created, updated)\n     * - Removing duplicate collections by id\n     * - Removing duplicate fields within each collection\n     * \n     * Use this before calling import() to ensure clean data.\n     * \n     * @param collections - Array of collection models to normalize\n     * @returns Normalized array of collections ready for import\n     */\n    normalizeForImport(collections: Array<CollectionModel>): Array<CollectionModel> {\n        // Remove duplicates by id\n        const seenIds = new Set<string>();\n        const uniqueCollections = collections.filter((collection) => {\n            if (collection.id && seenIds.has(collection.id)) {\n                return false;\n            }\n            if (collection.id) {\n                seenIds.add(collection.id);\n            }\n            return true;\n        });\n\n        // Normalize each collection\n        return uniqueCollections.map((collection) => {\n            const normalized = { ...collection };\n            \n            // Remove timestamps\n            delete (normalized as any).created;\n            delete (normalized as any).updated;\n            \n            // Remove duplicate fields by id\n            if (Array.isArray(normalized.fields)) {\n                const seenFieldIds = new Set<string>();\n                normalized.fields = normalized.fields.filter((field: any) => {\n                    if (field.id && seenFieldIds.has(field.id)) {\n                        return false;\n                    }\n                    if (field.id) {\n                        seenFieldIds.add(field.id);\n                    }\n                    return true;\n                });\n            }\n            \n            return normalized;\n        });\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and their fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     *\n     * **Warning**: This operation is destructive when `deleteMissing` is true.\n     * It's recommended to call `normalizeForImport()` on the collections\n     * before importing to ensure clean data.\n     *\n     * @param collections - Array of collection models to import\n     * @param deleteMissing - Whether to delete collections not present in the import (default: false)\n     * @param options - Optional request options\n     * @returns true if import succeeds\n     * @throws {ClientResponseError}\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        options?: CommonOptions,\n    ): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"PUT\",\n                body: {\n                    collections: collections,\n                    deleteMissing: deleteMissing,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/import\", options).then(() => true);\n    }\n\n    // -------------------------------------------------------------------\n    // Field Management Helpers\n    // -------------------------------------------------------------------\n\n    /**\n     * Adds a new field to the collection.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param field - Field definition (at minimum: name and type)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async addField(\n        collectionIdOrName: string,\n        field: Partial<CollectionField>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (!field.name || !field.type) {\n            throw new Error(\"Field name and type are required\");\n        }\n\n        // Check if field with this name already exists\n        if (collection.fields.find((f) => f.name === field.name)) {\n            throw new Error(`Field with name \"${field.name}\" already exists`);\n        }\n\n        // Initialize field with defaults\n        const newField: CollectionField = {\n            id: \"\",\n            name: field.name,\n            type: field.type,\n            system: false,\n            hidden: field.hidden ?? false,\n            presentable: field.presentable ?? false,\n            required: field.required ?? false,\n            ...field,\n        };\n\n        collection.fields.push(newField);\n\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Updates an existing field in the collection.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param fieldName - Name of the field to update\n     * @param updates - Field updates to apply\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async updateField(\n        collectionIdOrName: string,\n        fieldName: string,\n        updates: Partial<CollectionField>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        const fieldIndex = collection.fields.findIndex((f) => f.name === fieldName);\n        if (fieldIndex === -1) {\n            throw new Error(`Field with name \"${fieldName}\" not found`);\n        }\n\n        const field = collection.fields[fieldIndex];\n        \n        // Don't allow changing system fields\n        if (field.system && (updates.type || updates.name)) {\n            throw new Error(\"Cannot modify system fields\");\n        }\n\n        // If renaming, check for name conflicts\n        if (updates.name && updates.name !== fieldName) {\n            if (collection.fields.find((f) => f.name === updates.name && f.name !== fieldName)) {\n                throw new Error(`Field with name \"${updates.name}\" already exists`);\n            }\n        }\n\n        // Apply updates\n        Object.assign(field, updates);\n        collection.fields[fieldIndex] = field;\n\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Removes a field from the collection (deletes a table field).\n     * \n     * This method removes a field from the collection schema and automatically\n     * removes any indexes that reference the deleted field.\n     * \n     * **Note**: System fields cannot be removed.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param fieldName - Name of the field to remove\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if field not found or if attempting to remove a system field\n     */\n    async removeField(\n        collectionIdOrName: string,\n        fieldName: string,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        const fieldIndex = collection.fields.findIndex((f) => f.name === fieldName);\n        if (fieldIndex === -1) {\n            throw new Error(`Field with name \"${fieldName}\" not found`);\n        }\n\n        const field = collection.fields[fieldIndex];\n        \n        // Don't allow removing system fields\n        if (field.system) {\n            throw new Error(\"Cannot remove system fields\");\n        }\n\n        // Remove the field\n        collection.fields.splice(fieldIndex, 1);\n\n        // Remove indexes that reference this field\n        collection.indexes = collection.indexes.filter((idx) => {\n            // Parse index string to check if it contains this field\n            // Index format is typically like: \"CREATE INDEX idx_name ON table_name (column1, column2)\"\n            return !idx.includes(`(${fieldName})`) && !idx.includes(`(${fieldName},`) && !idx.includes(`, ${fieldName})`);\n        });\n\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Gets a field by name from the collection.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param fieldName - Name of the field to retrieve\n     * @param options - Optional request options\n     * @returns Field object or undefined if not found\n     * @throws {ClientResponseError}\n     */\n    async getField(\n        collectionIdOrName: string,\n        fieldName: string,\n        options?: CommonOptions,\n    ): Promise<CollectionField | undefined> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        return collection.fields.find((f) => f.name === fieldName);\n    }\n\n    // -------------------------------------------------------------------\n    // Index Management Helpers\n    // -------------------------------------------------------------------\n\n    /**\n     * Adds an index to the collection.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param columns - Array of column names to index\n     * @param unique - Whether the index should be unique (default: false)\n     * @param indexName - Optional custom index name\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async addIndex(\n        collectionIdOrName: string,\n        columns: Array<string>,\n        unique: boolean = false,\n        indexName?: string,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (!columns || columns.length === 0) {\n            throw new Error(\"At least one column must be specified\");\n        }\n\n        // Validate that all columns exist\n        const fieldNames = collection.fields.map((f) => f.name);\n        for (const column of columns) {\n            if (column !== \"id\" && !fieldNames.includes(column)) {\n                throw new Error(`Field \"${column}\" does not exist in the collection`);\n            }\n        }\n\n        // Generate index name if not provided\n        const idxName = indexName || `idx_${collection.name}_${columns.join(\"_\")}`;\n        const columnsStr = columns.map(col => `\\`${col}\\``).join(\", \");\n        const index = unique\n            ? `CREATE UNIQUE INDEX \\`${idxName}\\` ON \\`${collection.name}\\` (${columnsStr})`\n            : `CREATE INDEX \\`${idxName}\\` ON \\`${collection.name}\\` (${columnsStr})`;\n\n        // Check if index already exists\n        if (collection.indexes.includes(index)) {\n            throw new Error(\"Index already exists\");\n        }\n\n        collection.indexes.push(index);\n\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Removes an index from the collection (deletes a table index).\n     * \n     * This method removes an index that contains all the specified columns.\n     * The index is identified by matching all provided column names.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param columns - Array of column names that identify the index to remove\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if index not found\n     */\n    async removeIndex(\n        collectionIdOrName: string,\n        columns: Array<string>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (!columns || columns.length === 0) {\n            throw new Error(\"At least one column must be specified\");\n        }\n\n        // Find and remove indexes that match the columns\n        const initialLength = collection.indexes.length;\n        collection.indexes = collection.indexes.filter((idx) => {\n            // Check if index contains all the specified columns\n            // Handle both backticked and non-backticked formats\n            const hasAllColumns = columns.every(col => {\n                return idx.includes(`\\`${col}\\``) || idx.includes(`(${col})`) || \n                       idx.includes(`(${col},`) || idx.includes(`, ${col})`);\n            });\n            return !hasAllColumns;\n        });\n\n        if (collection.indexes.length === initialLength) {\n            throw new Error(\"Index not found\");\n        }\n\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Gets all indexes for the collection.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param options - Optional request options\n     * @returns Array of index strings\n     * @throws {ClientResponseError}\n     */\n    async getIndexes(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<Array<string>> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        return collection.indexes || [];\n    }\n\n    // -------------------------------------------------------------------\n    // API Rules Management Helpers\n    // -------------------------------------------------------------------\n\n    /**\n     * Sets the list rule (read/list access rule) for the collection.\n     * \n     * API Rules are collection access controls and data filters. Each rule can be:\n     * - `null` (locked) - Only superusers can perform the action (default)\n     * - `\"\"` (empty string) - Anyone can perform the action\n     * - Non-empty string - Only users satisfying the filter expression can perform the action\n     * \n     * Rules support filter syntax with operators (=, !=, >, <, ~, etc.), macros (@now, @request.auth.id, etc.),\n     * and modifiers (:isset, :length, :each, :lower).\n     * \n     * Examples:\n     * - Allow only registered users: `\"@request.auth.id != \\\"\\\"\"`\n     * - Filter by status: `\"status = \\\"active\\\"\"`\n     * - Combine conditions: `\"@request.auth.id != \\\"\\\" && (status = \\\"active\\\" || status = \\\"pending\\\")\"`\n     * - Filter by relation: `\"@request.auth.id != \\\"\\\" && author.id ?= @request.auth.id\"`\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param rule - Rule expression (use null, empty string, or \"\" to allow anyone; use non-empty string for filter)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async setListRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        collection.listRule = rule as any;\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Sets the view rule (read/view access rule) for the collection.\n     * \n     * See `setListRule` for details on rule syntax and examples.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param rule - Rule expression (use null, empty string, or \"\" to allow anyone; use non-empty string for filter)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async setViewRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        collection.viewRule = rule as any;\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Sets the create rule for the collection.\n     * \n     * See `setListRule` for details on rule syntax and examples.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param rule - Rule expression (use null, empty string, or \"\" to allow anyone; use non-empty string for filter)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async setCreateRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        collection.createRule = rule as any;\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Sets the update rule for the collection.\n     * \n     * See `setListRule` for details on rule syntax and examples.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param rule - Rule expression (use null, empty string, or \"\" to allow anyone; use non-empty string for filter)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async setUpdateRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        collection.updateRule = rule as any;\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Sets the delete rule for the collection.\n     * \n     * See `setListRule` for details on rule syntax and examples.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param rule - Rule expression (use null, empty string, or \"\" to allow anyone; use non-empty string for filter)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async setDeleteRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        collection.deleteRule = rule as any;\n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Sets all API rules at once for the collection.\n     * \n     * This is a convenience method to update multiple rules in a single operation.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param rules - Object containing rule expressions (listRule, viewRule, createRule, updateRule, deleteRule)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError}\n     */\n    async setRules(\n        collectionIdOrName: string,\n        rules: {\n            listRule?: string | null;\n            viewRule?: string | null;\n            createRule?: string | null;\n            updateRule?: string | null;\n            deleteRule?: string | null;\n        },\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (Object.prototype.hasOwnProperty.call(rules, \"listRule\")) {\n            collection.listRule = rules.listRule as any;\n        }\n        if (Object.prototype.hasOwnProperty.call(rules, \"viewRule\")) {\n            collection.viewRule = rules.viewRule as any;\n        }\n        if (Object.prototype.hasOwnProperty.call(rules, \"createRule\")) {\n            collection.createRule = rules.createRule as any;\n        }\n        if (Object.prototype.hasOwnProperty.call(rules, \"updateRule\")) {\n            collection.updateRule = rules.updateRule as any;\n        }\n        if (Object.prototype.hasOwnProperty.call(rules, \"deleteRule\")) {\n            collection.deleteRule = rules.deleteRule as any;\n        }\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Gets all API rules for the collection.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param options - Optional request options\n     * @returns Object containing all rules (listRule, viewRule, createRule, updateRule, deleteRule)\n     * @throws {ClientResponseError}\n     */\n    async getRules(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<{\n        listRule?: string;\n        viewRule?: string;\n        createRule?: string;\n        updateRule?: string;\n        deleteRule?: string;\n    }> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        return {\n            listRule: collection.listRule || undefined,\n            viewRule: collection.viewRule || undefined,\n            createRule: collection.createRule || undefined,\n            updateRule: collection.updateRule || undefined,\n            deleteRule: collection.deleteRule || undefined,\n        };\n    }\n\n    /**\n     * Sets the manage rule for an auth collection.\n     * \n     * ManageRule gives admin-like permissions to allow fully managing auth record(s),\n     * e.g. changing password without requiring the old one, directly updating verified state and email, etc.\n     * This rule is executed in addition to the Create and Update API rules.\n     * \n     * Only available for auth collections (type === \"auth\").\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param rule - Rule expression (use null to remove; empty string is not allowed for manageRule)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection\n     */\n    async setManageRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"ManageRule is only available for auth collections\");\n        }\n        \n        // AuthCollectionModel has manageRule as a direct property\n        const authCollection = collection as any;\n        authCollection.manageRule = rule as any;\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Sets the auth rule for an auth collection.\n     * \n     * AuthRule specifies additional record constraints applied after record authentication\n     * and right before returning the auth token response to the client.\n     * For example, to allow only verified users: `\"verified = true\"`\n     * \n     * Set to empty string to allow any Auth collection record to authenticate.\n     * Set to null to disallow authentication altogether for the collection.\n     * \n     * Only available for auth collections (type === \"auth\").\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param rule - Rule expression (use null to disallow auth; empty string to allow all; non-empty for filter)\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection\n     */\n    async setAuthRule(\n        collectionIdOrName: string,\n        rule: string | null,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"AuthRule is only available for auth collections\");\n        }\n        \n        // AuthCollectionModel has authRule as a direct property\n        const authCollection = collection as any;\n        authCollection.authRule = rule as any;\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    // -------------------------------------------------------------------\n    // Schema Query Methods\n    // -------------------------------------------------------------------\n\n    /**\n     * Gets the schema (fields and types) for a single collection.\n     * \n     * This method returns simplified schema information containing only\n     * field names, types, and basic metadata (required, system, hidden flags).\n     * This is useful for AI systems to understand the structure of collections\n     * without fetching the full collection definition.\n     * \n     * @param collectionIdOrName - Collection id or name\n     * @param options - Optional request options\n     * @returns Collection schema information\n     * @throws {ClientResponseError}\n     */\n    async getSchema(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<CollectionSchemaInfo> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send<CollectionSchemaInfo>(\n            this.baseCrudPath + \"/\" + encodeURIComponent(collectionIdOrName) + \"/schema\",\n            options,\n        );\n    }\n\n    /**\n     * Gets the schema (fields and types) for all collections in the system.\n     * \n     * This method returns simplified schema information for all collections,\n     * containing only field names, types, and basic metadata (required, system, hidden flags).\n     * This is useful for AI systems to understand the overall structure of the system\n     * and all available collections without fetching full collection definitions.\n     * \n     * @param options - Optional request options\n     * @returns Object containing array of collection schemas\n     * @throws {ClientResponseError}\n     */\n    async getAllSchemas(\n        options?: CommonOptions,\n    ): Promise<{ collections: Array<CollectionSchemaInfo> }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send<{ collections: Array<CollectionSchemaInfo> }>(\n            this.baseCrudPath + \"/schemas\",\n            options,\n        );\n    }\n\n    // -------------------------------------------------------------------\n    // OAuth2 Configuration Methods\n    // -------------------------------------------------------------------\n\n    /**\n     * Enables OAuth2 authentication for an auth collection.\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection\n     */\n    async enableOAuth2(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        if (!authCollection.oauth2) {\n            authCollection.oauth2 = { enabled: true, mappedFields: {}, providers: [] };\n        } else {\n            authCollection.oauth2.enabled = true;\n        }\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Disables OAuth2 authentication for an auth collection.\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection\n     */\n    async disableOAuth2(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        if (authCollection.oauth2) {\n            authCollection.oauth2.enabled = false;\n        }\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Gets the OAuth2 configuration for an auth collection.\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param options - Optional request options\n     * @returns OAuth2 configuration object\n     * @throws {ClientResponseError} if collection is not an auth collection\n     */\n    async getOAuth2Config(\n        collectionIdOrName: string,\n        options?: CommonOptions,\n    ): Promise<{ enabled: boolean; mappedFields: { [key: string]: string }; providers: Array<any> }> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        return {\n            enabled: authCollection.oauth2?.enabled ?? false,\n            mappedFields: authCollection.oauth2?.mappedFields ?? {},\n            providers: authCollection.oauth2?.providers ?? [],\n        };\n    }\n\n    /**\n     * Sets the OAuth2 mapped fields for an auth collection.\n     * \n     * Mapped fields define how OAuth2 provider user data maps to collection fields.\n     * For example: { \"name\": \"name\", \"email\": \"email\", \"avatarUrl\": \"avatar\" }\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param mappedFields - Object mapping OAuth2 fields to collection fields\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection\n     */\n    async setOAuth2MappedFields(\n        collectionIdOrName: string,\n        mappedFields: { [key: string]: string },\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        if (!authCollection.oauth2) {\n            authCollection.oauth2 = { enabled: false, mappedFields: {}, providers: [] };\n        }\n        authCollection.oauth2.mappedFields = mappedFields;\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Adds a new OAuth2 provider to an auth collection.\n     * \n     * Before using this method, you need to:\n     * 1. Create an OAuth2 app in the provider's dashboard\n     * 2. Get the Client ID and Client Secret\n     * 3. Register a redirect URL (typically: https://yourdomain.com/api/oauth2-redirect)\n     * \n     * Supported provider names include: \"google\", \"github\", \"gitlab\", \"discord\", \n     * \"facebook\", \"microsoft\", \"apple\", \"twitter\", \"spotify\", \"kakao\", \"twitch\", \n     * \"strava\", \"vk\", \"yandex\", \"patreon\", \"linkedin\", \"instagram\", \"vimeo\", \n     * \"digitalocean\", \"bitbucket\", \"dropbox\", \"planningcenter\", \"notion\", \"linear\", \n     * \"oidc\", \"oidc2\", \"oidc3\", and more.\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param provider - OAuth2 provider configuration\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection or provider is invalid\n     */\n    async addOAuth2Provider(\n        collectionIdOrName: string,\n        provider: {\n            name: string;\n            clientId: string;\n            clientSecret: string;\n            authURL: string;\n            tokenURL: string;\n            userInfoURL: string;\n            displayName?: string;\n            pkce?: boolean;\n            extra?: { [key: string]: any };\n        },\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        if (!authCollection.oauth2) {\n            authCollection.oauth2 = { enabled: false, mappedFields: {}, providers: [] };\n        }\n        \n        // Check if provider with this name already exists\n        const existingProvider = authCollection.oauth2.providers.find(\n            (p: any) => p.name === provider.name\n        );\n        if (existingProvider) {\n            throw new Error(`OAuth2 provider with name \"${provider.name}\" already exists`);\n        }\n        \n        // Add the new provider\n        authCollection.oauth2.providers.push({\n            name: provider.name,\n            clientId: provider.clientId,\n            clientSecret: provider.clientSecret,\n            authURL: provider.authURL,\n            tokenURL: provider.tokenURL,\n            userInfoURL: provider.userInfoURL,\n            displayName: provider.displayName || provider.name,\n            pkce: provider.pkce,\n            extra: provider.extra,\n        });\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Updates an existing OAuth2 provider in an auth collection.\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param providerName - Name of the provider to update\n     * @param updates - Partial provider configuration to update\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection or provider not found\n     */\n    async updateOAuth2Provider(\n        collectionIdOrName: string,\n        providerName: string,\n        updates: Partial<{\n            clientId: string;\n            clientSecret: string;\n            authURL: string;\n            tokenURL: string;\n            userInfoURL: string;\n            displayName: string;\n            pkce: boolean;\n            extra: { [key: string]: any };\n        }>,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        if (!authCollection.oauth2) {\n            throw new Error(\"OAuth2 is not configured for this collection\");\n        }\n        \n        const providerIndex = authCollection.oauth2.providers.findIndex(\n            (p: any) => p.name === providerName\n        );\n        if (providerIndex === -1) {\n            throw new Error(`OAuth2 provider with name \"${providerName}\" not found`);\n        }\n        \n        // Update the provider\n        const provider = authCollection.oauth2.providers[providerIndex];\n        Object.assign(provider, updates);\n        authCollection.oauth2.providers[providerIndex] = provider;\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n\n    /**\n     * Removes an OAuth2 provider from an auth collection.\n     * \n     * @param collectionIdOrName - Auth collection id or name\n     * @param providerName - Name of the provider to remove\n     * @param options - Optional request options\n     * @returns Updated collection model\n     * @throws {ClientResponseError} if collection is not an auth collection or provider not found\n     */\n    async removeOAuth2Provider(\n        collectionIdOrName: string,\n        providerName: string,\n        options?: CommonOptions,\n    ): Promise<CollectionModel> {\n        const collection = await this.getOne(collectionIdOrName, options);\n        \n        if (collection.type !== \"auth\") {\n            throw new Error(\"OAuth2 is only available for auth collections\");\n        }\n        \n        const authCollection = collection as any;\n        if (!authCollection.oauth2) {\n            throw new Error(\"OAuth2 is not configured for this collection\");\n        }\n        \n        const providerIndex = authCollection.oauth2.providers.findIndex(\n            (p: any) => p.name === providerName\n        );\n        if (providerIndex === -1) {\n            throw new Error(`OAuth2 provider with name \"${providerName}\" not found`);\n        }\n        \n        // Remove the provider\n        authCollection.oauth2.providers.splice(providerIndex, 1);\n        \n        return this.update(collectionIdOrName, collection, options);\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { ListResult, LogModel } from \"@/tools/dtos\";\nimport { CommonOptions, ListOptions, LogStatsOptions } from \"@/tools/options\";\n\nexport interface HourlyStats {\n    total: number;\n    date: string;\n}\n\nexport class LogService extends BaseService {\n    /**\n     * Returns paginated logs list.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<LogModel>> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(\"/api/logs\", options);\n    }\n\n    /**\n     * Returns a single log by its id.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne(id: string, options?: CommonOptions): Promise<LogModel> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildURL(\"/api/logs/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required log id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/\" + encodeURIComponent(id), options);\n    }\n\n    /**\n     * Returns logs statistics.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/stats\", options);\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface HealthCheckResponse {\n    code: number;\n    message: string;\n    data: { [key: string]: any };\n}\n\nexport class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     *\n     * @throws {ClientResponseError}\n     */\n    async check(options?: CommonOptions): Promise<HealthCheckResponse> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/health\", options);\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions, FileOptions } from \"@/tools/options\";\n\nexport class FileService extends BaseService {\n    /**\n     * @deprecated Please replace with `pb.files.getURL()`.\n     */\n    getUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        console.warn(\"Please replace pb.files.getUrl() with pb.files.getURL()\");\n        return this.getURL(record, filename, queryParams);\n    }\n\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getURL(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        if (\n            !filename ||\n            !record?.id ||\n            !(record?.collectionId || record?.collectionName)\n        ) {\n            return \"\";\n        }\n\n        const parts = [];\n        parts.push(\"api\");\n        parts.push(\"files\");\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName));\n        parts.push(encodeURIComponent(record.id));\n        parts.push(encodeURIComponent(filename));\n\n        let result = this.client.buildURL(parts.join(\"/\"));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete queryParams.download;\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result;\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getToken(options?: CommonOptions): Promise<string> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\"/api/files/token\", options)\n            .then((data) => data?.token || \"\");\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface BackupFileInfo {\n    key: string;\n    size: number;\n    modified: string;\n}\n\nexport class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options);\n    }\n\n    /**\n     * Initializes a new backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create(basename: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    name: basename,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options).then(() => true);\n    }\n\n    /**\n     * Uploads an existing backup file.\n     *\n     * Example:\n     *\n     * ```js\n     * await pb.backups.upload({\n     *     file: new Blob([...]),\n     * });\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async upload(\n        bodyParams: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups/upload\", options).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async restore(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\n            .then(() => true);\n    }\n\n    /**\n     * @deprecated Please use `getDownloadURL()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        console.warn(\n            \"Please replace pb.backups.getDownloadUrl() with pb.backups.getDownloadURL()\",\n        );\n        return this.getDownloadURL(token, key);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using a\n     * superuser file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadURL(token: string, key: string): string {\n        return this.client.buildURL(\n            `/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`,\n        );\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface CronJob {\n    id: string;\n    expression: string;\n}\n\nexport class CronService extends BaseService {\n    /**\n     * Returns list with all registered cron jobs.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<CronJob>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/crons\", options);\n    }\n\n    /**\n     * Runs the specified cron job.\n     *\n     * @throws {ClientResponseError}\n     */\n    async run(jobId: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/crons/${encodeURIComponent(jobId)}`, options)\n            .then(() => true);\n    }\n}\n","/**\n * Checks if the specified value is a file (aka. File, Blob, RN file object).\n */\nexport function isFile(val: any): boolean {\n    return (\n        (typeof Blob !== \"undefined\" && val instanceof Blob) ||\n        (typeof File !== \"undefined\" && val instanceof File) ||\n        // check for React Native file object format\n        // (see https://github.com/bosbase/bosbase/discussions/2002#discussioncomment-5254168)\n        (val !== null &&\n            typeof val === \"object\" &&\n            val.uri &&\n            ((typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") ||\n                (typeof global !== \"undefined\" && (global as any).HermesInternal)))\n    );\n}\n\n/**\n * Loosely checks if the specified body is a FormData instance.\n */\nexport function isFormData(body: any): boolean {\n    return (\n        body &&\n        // we are checking the constructor name because FormData\n        // is not available natively in some environments and the\n        // polyfill(s) may not be globally accessible\n        (body.constructor?.name === \"FormData\" ||\n            // fallback to global FormData instance check\n            // note: this is needed because the constructor.name could be different in case of\n            //       custom global FormData implementation, eg. React Native on Android/iOS\n            (typeof FormData !== \"undefined\" && body instanceof FormData))\n    );\n}\n\n/**\n * Checks if the submitted body object has at least one Blob/File field value.\n */\nexport function hasFileField(body: { [key: string]: any }): boolean {\n    for (const key in body) {\n        const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n        for (const v of values) {\n            if (isFile(v)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Converts analyzes the provided body and converts it to FormData\n * in case a plain object with File/Blob values is used.\n */\nexport function convertToFormDataIfNeeded(body: any): any {\n    if (\n        typeof FormData === \"undefined\" ||\n        typeof body === \"undefined\" ||\n        typeof body !== \"object\" ||\n        body === null ||\n        isFormData(body) ||\n        !hasFileField(body)\n    ) {\n        return body;\n    }\n\n    const form = new FormData();\n\n    for (const key in body) {\n        const val = body[key];\n\n        // skip undefined values for consistency with JSON.stringify\n        // (see https://github.com/bosbase/bosbase/issues/6731#issuecomment-2812382827)\n        if (typeof val === \"undefined\") {\n            continue;\n        }\n\n        if (typeof val === \"object\" && !hasFileField({ data: val })) {\n            // send json-like values as jsonPayload to avoid the implicit string value normalization\n            let payload: { [key: string]: any } = {};\n            payload[key] = val;\n            form.append(\"@jsonPayload\", JSON.stringify(payload));\n        } else {\n            // in case of mixed string and file/blob\n            const normalizedVal = Array.isArray(val) ? val : [val];\n            for (let v of normalizedVal) {\n                form.append(key, v);\n            }\n        }\n    }\n\n    return form;\n}\n\n/**\n * Converts the provided FormData instance into a plain object.\n *\n * For consistency with the server multipart/form-data inferring,\n * the following normalization rules are applied for plain multipart string values:\n *   - \"true\" is converted to the json \"true\"\n *   - \"false\" is converted to the json \"false\"\n *   - numeric strings are converted to json number ONLY if the resulted\n *     minimal number string representation is the same as the provided raw string\n *     (aka. scientific notations, \"Infinity\", \"0.0\", \"0001\", etc. are kept as string)\n *   - any other string (empty string too) is left as it is\n */\nexport function convertFormDataToObject(formData: FormData): { [key: string]: any } {\n    let result: { [key: string]: any } = {};\n\n    formData.forEach((v, k) => {\n        if (k === \"@jsonPayload\" && typeof v == \"string\") {\n            try {\n                let parsed = JSON.parse(v);\n                Object.assign(result, parsed);\n            } catch (err) {\n                console.warn(\"@jsonPayload error:\", err);\n            }\n        } else {\n            if (typeof result[k] !== \"undefined\") {\n                if (!Array.isArray(result[k])) {\n                    result[k] = [result[k]];\n                }\n                result[k].push(inferFormDataValue(v));\n            } else {\n                result[k] = inferFormDataValue(v);\n            }\n        }\n    });\n\n    return result;\n}\n\nconst inferNumberCharsRegex = /^[\\-\\.\\d]+$/;\n\nfunction inferFormDataValue(value: any): any {\n    if (typeof value != \"string\") {\n        return value;\n    }\n\n    if (value == \"true\") {\n        return true;\n    }\n\n    if (value == \"false\") {\n        return false;\n    }\n\n    // note: expects the provided raw string to match exactly with the minimal string representation of the parsed number\n    if (\n        (value[0] === \"-\" || (value[0] >= \"0\" && value[0] <= \"9\")) &&\n        inferNumberCharsRegex.test(value)\n    ) {\n        let num = +value;\n        if (\"\" + num === value) {\n            return num;\n        }\n    }\n\n    return value;\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { isFile, isFormData, convertFormDataToObject } from \"@/tools/formdata\";\nimport {\n    SendOptions,\n    RecordOptions,\n    normalizeUnknownQueryParams,\n    serializeQueryParams,\n} from \"@/tools/options\";\n\nexport interface BatchRequest {\n    method: string;\n    url: string;\n    json?: { [key: string]: any };\n    files?: { [key: string]: Array<any> };\n    headers?: { [key: string]: string };\n}\n\nexport interface BatchRequestResult {\n    status: number;\n    body: any;\n}\n\nexport class BatchService extends BaseService {\n    private requests: Array<BatchRequest> = [];\n    private subs: { [key: string]: SubBatchService } = {};\n\n    /**\n     * Starts constructing a batch request entry for the specified collection.\n     */\n    collection(collectionIdOrName: string): SubBatchService {\n        if (!this.subs[collectionIdOrName]) {\n            this.subs[collectionIdOrName] = new SubBatchService(\n                this.requests,\n                collectionIdOrName,\n            );\n        }\n\n        return this.subs[collectionIdOrName];\n    }\n\n    /**\n     * Sends the batch requests.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send(options?: SendOptions): Promise<Array<BatchRequestResult>> {\n        const formData = new FormData();\n\n        const jsonData = [];\n\n        for (let i = 0; i < this.requests.length; i++) {\n            const req = this.requests[i];\n\n            jsonData.push({\n                method: req.method,\n                url: req.url,\n                headers: req.headers,\n                body: req.json,\n            });\n\n            if (req.files) {\n                for (let key in req.files) {\n                    const files = req.files[key] || [];\n                    for (let file of files) {\n                        formData.append(\"requests.\" + i + \".\" + key, file);\n                    }\n                }\n            }\n        }\n\n        formData.append(\"@jsonPayload\", JSON.stringify({ requests: jsonData }));\n\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: formData,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/batch\", options);\n    }\n}\n\nexport class SubBatchService {\n    private requests: Array<BatchRequest> = [];\n    private readonly collectionIdOrName: string;\n\n    constructor(requests: Array<BatchRequest>, collectionIdOrName: string) {\n        this.requests = requests;\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * Registers a record upsert request into the current batch queue.\n     *\n     * The request will be executed as update if `bodyParams` have a valid existing record `id` value, otherwise - create.\n     */\n    upsert(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"PUT\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records\",\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record create request into the current batch queue.\n     */\n    create(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"POST\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records\",\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record update request into the current batch queue.\n     */\n    update(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"PATCH\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records/\" +\n                encodeURIComponent(id),\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record delete request into the current batch queue.\n     */\n    delete(id: string, options?: SendOptions): void {\n        options = Object.assign({}, options);\n\n        const request: BatchRequest = {\n            method: \"DELETE\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records/\" +\n                encodeURIComponent(id),\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    private prepareRequest(request: BatchRequest, options: SendOptions) {\n        normalizeUnknownQueryParams(options);\n\n        request.headers = options.headers;\n        request.json = {};\n        request.files = {};\n\n        // serialize query parameters\n        // -----------------------------------------------------------\n        if (typeof options.query !== \"undefined\") {\n            const query = serializeQueryParams(options.query);\n            if (query) {\n                request.url += (request.url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n        }\n\n        // extract json and files body data\n        // -----------------------------------------------------------\n        let body = options.body;\n        if (isFormData(body)) {\n            body = convertFormDataToObject(body);\n        }\n\n        for (const key in body) {\n            const val = body[key];\n\n            if (isFile(val)) {\n                request.files[key] = request.files[key] || [];\n                request.files[key].push(val);\n            } else if (Array.isArray(val)) {\n                const foundFiles = [];\n                const foundRegular = [];\n                for (const v of val) {\n                    if (isFile(v)) {\n                        foundFiles.push(v);\n                    } else {\n                        foundRegular.push(v);\n                    }\n                }\n\n                if (foundFiles.length > 0 && foundFiles.length == val.length) {\n                    // only files\n                    // ---\n                    request.files[key] = request.files[key] || [];\n                    for (let file of foundFiles) {\n                        request.files[key].push(file);\n                    }\n                } else {\n                    // empty or mixed array (both regular and File/Blob values)\n                    // ---\n                    request.json[key] = foundRegular;\n\n                    if (foundFiles.length > 0) {\n                        // add \"+\" to append if not already since otherwise\n                        // the existing regular files will be deleted\n                        // (the mixed values order is preserved only within their corresponding groups)\n                        let fileKey = key;\n                        if (!key.startsWith(\"+\") && !key.endsWith(\"+\")) {\n                            fileKey += \"+\";\n                        }\n\n                        request.files[fileKey] = request.files[fileKey] || [];\n                        for (let file of foundFiles) {\n                            request.files[fileKey].push(file);\n                        }\n                    }\n                }\n            } else {\n                request.json[key] = val;\n            }\n        }\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport {\n    VectorDocument,\n    VectorSearchOptions,\n    VectorSearchResponse,\n    VectorBatchInsertOptions,\n    VectorBatchInsertResponse,\n    VectorInsertResponse,\n} from \"@/tools/vector-types\";\nimport { SendOptions } from \"@/tools/options\";\n\nexport interface VectorServiceOptions extends SendOptions {\n    /**\n     * Collection or table name to operate on.\n     */\n    collection?: string;\n}\n\n/**\n * VectorService provides an abstracted interface for vector database operations.\n * This abstraction allows support for multiple vector databases through a unified API.\n */\nexport class VectorService extends BaseService {\n    /**\n     * Base path for vector operations.\n     */\n    private get baseVectorPath(): string {\n        return \"/api/vectors\";\n    }\n\n    /**\n     * Ensures a collection name is provided for collection-scoped endpoints.\n     */\n    private requireCollection(options?: VectorServiceOptions): string {\n        const collection = options?.collection;\n        if (!collection) {\n            throw new Error(\"collection is required for this operation\");\n        }\n        return collection;\n    }\n\n    /**\n     * Collection-specific path.\n     */\n    private getPath(collection?: string): string {\n        if (collection) {\n            return `${this.baseVectorPath}/${encodeURIComponent(collection)}`;\n        }\n        return this.baseVectorPath;\n    }\n\n    /**\n     * Insert a single vector document.\n     *\n     * @example\n     * ```js\n     * const result = await pb.vectors.insert({\n     *     vector: [0.1, 0.2, 0.3],\n     *     metadata: { category: 'example' },\n     *     content: 'Example text'\n     * }, { collection: 'documents' });\n     * ```\n     */\n    async insert(\n        document: VectorDocument,\n        options?: VectorServiceOptions,\n    ): Promise<VectorInsertResponse> {\n        const path = this.getPath(this.requireCollection(options));\n\n        return this.client.send<VectorInsertResponse>(path, {\n            method: \"POST\",\n            body: document,\n            ...options,\n        });\n    }\n\n    /**\n     * Insert multiple vector documents in a batch.\n     *\n     * @example\n     * ```js\n     * const result = await pb.vectors.batchInsert({\n     *     documents: [\n     *         { vector: [0.1, 0.2, 0.3], content: 'Example 1' },\n     *         { vector: [0.4, 0.5, 0.6], content: 'Example 2' }\n     *     ],\n     *     skipDuplicates: true\n     * }, { collection: 'documents' });\n     * ```\n     */\n    async batchInsert(\n        data: VectorBatchInsertOptions,\n        options?: VectorServiceOptions,\n    ): Promise<VectorBatchInsertResponse> {\n        const path = `${this.getPath(this.requireCollection(options))}/documents/batch`;\n\n        return this.client.send<VectorBatchInsertResponse>(path, {\n            method: \"POST\",\n            body: data,\n            ...options,\n        });\n    }\n\n    /**\n     * Update an existing vector document.\n     *\n     * @example\n     * ```js\n     * const result = await pb.vectors.update('doc_id', {\n     *     vector: [0.1, 0.2, 0.3],\n     *     metadata: { updated: true }\n     * }, { collection: 'documents' });\n     * ```\n     */\n    async update(\n        id: string,\n        document: Partial<VectorDocument>,\n        options?: VectorServiceOptions,\n    ): Promise<VectorInsertResponse> {\n        const path = `${this.getPath(this.requireCollection(options))}/${encodeURIComponent(id)}`;\n\n        return this.client.send<VectorInsertResponse>(path, {\n            method: \"PATCH\",\n            body: document,\n            ...options,\n        });\n    }\n\n    /**\n     * Delete a vector document by ID.\n     *\n     * @example\n     * ```js\n     * await pb.vectors.delete('doc_id', { collection: 'documents' });\n     * ```\n     */\n    async delete(id: string, options?: VectorServiceOptions): Promise<void> {\n        const path = `${this.getPath(this.requireCollection(options))}/${encodeURIComponent(id)}`;\n\n        await this.client.send(path, {\n            method: \"DELETE\",\n            ...options,\n        });\n    }\n\n    /**\n     * Search for similar vectors.\n     *\n     * @example\n     * ```js\n     * const results = await pb.vectors.search({\n     *     queryVector: [0.1, 0.2, 0.3],\n     *     limit: 10,\n     *     minScore: 0.7\n     * }, { collection: 'documents' });\n     * ```\n     */\n    async search(\n        searchOptions: VectorSearchOptions,\n        options?: VectorServiceOptions,\n    ): Promise<VectorSearchResponse> {\n        const path = `${this.getPath(this.requireCollection(options))}/documents/search`;\n\n        return this.client.send<VectorSearchResponse>(path, {\n            method: \"POST\",\n            body: searchOptions,\n            ...options,\n        });\n    }\n\n    /**\n     * Get a vector document by ID.\n     *\n     * @example\n     * ```js\n     * const doc = await pb.vectors.get('doc_id', { collection: 'documents' });\n     * ```\n     */\n    async get(id: string, options?: VectorServiceOptions): Promise<VectorDocument> {\n        const path = `${this.getPath(this.requireCollection(options))}/${encodeURIComponent(id)}`;\n\n        return this.client.send<VectorDocument>(path, {\n            method: \"GET\",\n            ...options,\n        });\n    }\n\n    /**\n     * List all vector documents in a collection (with optional pagination).\n     *\n     * @example\n     * ```js\n     * const docs = await pb.vectors.list({\n     *     page: 1,\n     *     perPage: 100\n     * }, { collection: 'documents' });\n     * ```\n     */\n    async list(\n        options?: VectorServiceOptions & { page?: number; perPage?: number },\n    ): Promise<{ items: VectorDocument[]; page: number; perPage: number; totalItems: number }> {\n        const collection = this.requireCollection(options);\n        const path = this.getPath(collection);\n\n        return this.client.send(path, {\n            method: \"GET\",\n            query: {\n                page: options?.page,\n                perPage: options?.perPage,\n                ...(options?.query ?? {}),\n            },\n            ...options,\n        });\n    }\n\n    /**\n     * Create or ensure a vector collection/table exists.\n     *\n     * @example\n     * ```js\n     * await pb.vectors.createCollection('documents', {\n     *     dimension: 384,\n     *     distance: 'cosine'\n     * });\n     * ```\n     */\n    async createCollection(\n        name: string,\n        config?: { dimension?: number; distance?: string },\n        options?: VectorServiceOptions,\n    ): Promise<void> {\n        const path = `${this.getPath()}/collections/${encodeURIComponent(name)}`;\n\n        await this.client.send(path, {\n            method: \"POST\",\n            body: config || {},\n            ...options,\n        });\n    }\n\n    /**\n     * Update a vector collection configuration (distance metric and options).\n     * Note: Collection name and dimension cannot be changed after creation.\n     *\n     * @example\n     * ```js\n     * await pb.vectors.updateCollection('documents', {\n     *     distance: 'l2'  // Change from cosine to L2\n     * });\n     * ```\n     */\n    async updateCollection(\n        name: string,\n        config?: { distance?: string; options?: Record<string, any> },\n        options?: VectorServiceOptions,\n    ): Promise<void> {\n        const path = `${this.getPath()}/collections/${encodeURIComponent(name)}`;\n\n        await this.client.send(path, {\n            method: \"PATCH\",\n            body: config || {},\n            ...options,\n        });\n    }\n\n    /**\n     * Delete a vector collection/table.\n     *\n     * @example\n     * ```js\n     * await pb.vectors.deleteCollection('documents');\n     * ```\n     */\n    async deleteCollection(name: string, options?: VectorServiceOptions): Promise<void> {\n        const path = `${this.getPath()}/collections/${encodeURIComponent(name)}`;\n\n        await this.client.send(path, {\n            method: \"DELETE\",\n            ...options,\n        });\n    }\n\n    /**\n     * List all available vector collections.\n     *\n     * @example\n     * ```js\n     * const collections = await pb.vectors.listCollections();\n     * ```\n     */\n    async listCollections(\n        options?: VectorServiceOptions,\n    ): Promise<Array<{ name: string; dimension?: number; distance?: string; count?: number; id?: string }>> {\n        const path = `${this.getPath()}/collections`;\n\n        return this.client.send(path, {\n            method: \"GET\",\n            ...options,\n        });\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { SendOptions } from \"@/tools/options\";\nimport {\n    LLMDocument,\n    LLMDocumentUpdate,\n    LLMQueryOptions,\n    LLMQueryResult,\n} from \"@/tools/llm-types\";\n\nexport interface LLMServiceOptions extends SendOptions {\n    collection: string;\n}\n\nexport class LLMDocumentService extends BaseService {\n    private get basePath(): string {\n        return \"/api/llm-documents\";\n    }\n\n    private collectionsPath(): string {\n        return `${this.basePath}/collections`;\n    }\n\n    private collectionPath(collection: string): string {\n        if (!collection) {\n            throw new Error(\"collection is required\");\n        }\n        return `${this.basePath}/${encodeURIComponent(collection)}`;\n    }\n\n    async listCollections(options?: SendOptions): Promise<Array<{ name: string; count: number; metadata: Record<string, string> }>> {\n        return this.client.send(this.collectionsPath(), {\n            method: \"GET\",\n            ...options,\n        });\n    }\n\n    async createCollection(\n        name: string,\n        metadata?: Record<string, string>,\n        options?: SendOptions,\n    ): Promise<void> {\n        await this.client.send(`${this.collectionsPath()}/${encodeURIComponent(name)}`, {\n            method: \"POST\",\n            body: { metadata },\n            ...options,\n        });\n    }\n\n    async deleteCollection(name: string, options?: SendOptions): Promise<void> {\n        await this.client.send(`${this.collectionsPath()}/${encodeURIComponent(name)}`, {\n            method: \"DELETE\",\n            ...options,\n        });\n    }\n\n    async insert(document: LLMDocument, options: LLMServiceOptions): Promise<{ id: string; success: boolean }> {\n        return this.client.send(this.collectionPath(options.collection), {\n            method: \"POST\",\n            body: document,\n            ...options,\n        });\n    }\n\n    async get(id: string, options: LLMServiceOptions): Promise<LLMDocument> {\n        return this.client.send(`${this.collectionPath(options.collection)}/${encodeURIComponent(id)}`, {\n            method: \"GET\",\n            ...options,\n        });\n    }\n\n    async update(\n        id: string,\n        document: LLMDocumentUpdate,\n        options: LLMServiceOptions,\n    ): Promise<{ success: boolean }> {\n        return this.client.send(`${this.collectionPath(options.collection)}/${encodeURIComponent(id)}`, {\n            method: \"PATCH\",\n            body: document,\n            ...options,\n        });\n    }\n\n    async delete(id: string, options: LLMServiceOptions): Promise<void> {\n        await this.client.send(`${this.collectionPath(options.collection)}/${encodeURIComponent(id)}`, {\n            method: \"DELETE\",\n            ...options,\n        });\n    }\n\n    async list(\n        options: LLMServiceOptions & { page?: number; perPage?: number },\n    ): Promise<{ items: LLMDocument[]; page: number; perPage: number; totalItems: number }> {\n        return this.client.send(this.collectionPath(options.collection), {\n            method: \"GET\",\n            query: {\n                page: options.page,\n                perPage: options.perPage,\n                ...(options.query ?? {}),\n            },\n            ...options,\n        });\n    }\n\n    async query(\n        payload: LLMQueryOptions,\n        options: LLMServiceOptions,\n    ): Promise<{ results: LLMQueryResult[] }> {\n        return this.client.send(`${this.collectionPath(options.collection)}/documents/query`, {\n            method: \"POST\",\n            body: payload,\n            ...options,\n        });\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface CacheConfigSummary {\n    name: string;\n    sizeBytes: number;\n    defaultTTLSeconds: number;\n    readTimeoutMs: number;\n    created: string;\n    updated: string;\n}\n\nexport interface CacheEntry<T = any> {\n    cache: string;\n    key: string;\n    value: T;\n    source: \"cache\" | \"database\";\n    expiresAt?: string;\n}\n\nexport interface CreateCacheBody {\n    name: string;\n    sizeBytes?: number;\n    defaultTTLSeconds?: number;\n    readTimeoutMs?: number;\n}\n\nexport interface UpdateCacheBody {\n    sizeBytes?: number;\n    defaultTTLSeconds?: number;\n    readTimeoutMs?: number;\n}\n\nexport interface CacheEntryBody<T = any> {\n    value: T;\n    ttlSeconds?: number;\n}\n\nexport class CacheService extends BaseService {\n    /**\n     * Lists all configured caches.\n     */\n    async list(options?: CommonOptions): Promise<CacheConfigSummary[]> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        const response = await this.client.send(\"/api/cache\", options);\n        return response?.items ?? [];\n    }\n\n    /**\n     * Creates a cache configuration.\n     */\n    async create(\n        body: CreateCacheBody,\n        options?: CommonOptions,\n    ): Promise<CacheConfigSummary> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/cache\", options);\n    }\n\n    /**\n     * Updates a cache configuration.\n     */\n    async update(\n        name: string,\n        body: UpdateCacheBody,\n        options?: CommonOptions,\n    ): Promise<CacheConfigSummary> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body,\n            },\n            options,\n        );\n\n        return this.client.send(`/api/cache/${encodeURIComponent(name)}`, options);\n    }\n\n    /**\n     * Deletes a cache.\n     */\n    async delete(name: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({ method: \"DELETE\" }, options);\n\n        await this.client.send(`/api/cache/${encodeURIComponent(name)}`, options);\n        return true;\n    }\n\n    /**\n     * Creates or replaces a cache entry.\n     */\n    async setEntry<T = any>(\n        cache: string,\n        key: string,\n        value: T,\n        ttlSeconds?: number,\n        options?: CommonOptions,\n    ): Promise<CacheEntry<T>> {\n        const body: CacheEntryBody<T> = { value };\n        if (typeof ttlSeconds === \"number\") {\n            body.ttlSeconds = ttlSeconds;\n        }\n\n        options = Object.assign(\n            {\n                method: \"PUT\",\n                body,\n            },\n            options,\n        );\n\n        return this.client.send(\n            `/api/cache/${encodeURIComponent(cache)}/entries/${encodeURIComponent(key)}`,\n            options,\n        );\n    }\n\n    /**\n     * Reads a cache entry.\n     */\n    async getEntry<T = any>(\n        cache: string,\n        key: string,\n        options?: CommonOptions,\n    ): Promise<CacheEntry<T>> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        return this.client.send(\n            `/api/cache/${encodeURIComponent(cache)}/entries/${encodeURIComponent(key)}`,\n            options,\n        );\n    }\n\n    /**\n     * Renews a cache entry by extending its TTL without changing its value.\n     * If the entry doesn't exist, it will throw an error.\n     */\n    async renewEntry<T = any>(\n        cache: string,\n        key: string,\n        ttlSeconds?: number,\n        options?: CommonOptions,\n    ): Promise<CacheEntry<T>> {\n        const body: { ttlSeconds?: number } = {};\n        if (typeof ttlSeconds === \"number\") {\n            body.ttlSeconds = ttlSeconds;\n        }\n\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body,\n            },\n            options,\n        );\n\n        return this.client.send(\n            `/api/cache/${encodeURIComponent(cache)}/entries/${encodeURIComponent(key)}`,\n            options,\n        );\n    }\n\n    /**\n     * Deletes a cache entry.\n     */\n    async deleteEntry(\n        cache: string,\n        key: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign({ method: \"DELETE\" }, options);\n\n        await this.client.send(\n            `/api/cache/${encodeURIComponent(cache)}/entries/${encodeURIComponent(key)}`,\n            options,\n        );\n\n        return true;\n    }\n}\n\n","import { BaseService } from \"@/services/BaseService\";\nimport { SendOptions } from \"@/tools/options\";\nimport {\n    LangChaingoCompletionRequest,\n    LangChaingoCompletionResponse,\n    LangChaingoRAGRequest,\n    LangChaingoRAGResponse,\n    LangChaingoDocumentQueryRequest,\n    LangChaingoDocumentQueryResponse,\n    LangChaingoSQLRequest,\n    LangChaingoSQLResponse,\n} from \"@/tools/langchaingo-types\";\n\nexport class LangChaingoService extends BaseService {\n    private basePath(): string {\n        return \"/api/langchaingo\";\n    }\n\n    /**\n     * Invokes `/api/langchaingo/completions`.\n     */\n    async completions(\n        payload: LangChaingoCompletionRequest,\n        options: SendOptions = {},\n    ): Promise<LangChaingoCompletionResponse> {\n        return this.client.send(`${this.basePath()}/completions`, {\n            method: \"POST\",\n            body: payload,\n            ...options,\n        });\n    }\n\n    /**\n     * Invokes `/api/langchaingo/rag`.\n     */\n    async rag(\n        payload: LangChaingoRAGRequest,\n        options: SendOptions = {},\n    ): Promise<LangChaingoRAGResponse> {\n        return this.client.send(`${this.basePath()}/rag`, {\n            method: \"POST\",\n            body: payload,\n            ...options,\n        });\n    }\n\n    /**\n     * Invokes `/api/langchaingo/documents/query`.\n     */\n    async queryDocuments(\n        payload: LangChaingoDocumentQueryRequest,\n        options: SendOptions = {},\n    ): Promise<LangChaingoDocumentQueryResponse> {\n        return this.client.send(`${this.basePath()}/documents/query`, {\n            method: \"POST\",\n            body: payload,\n            ...options,\n        });\n    }\n\n    /**\n     * Invokes `/api/langchaingo/sql`.\n     */\n    async sql(\n        payload: LangChaingoSQLRequest,\n        options: SendOptions = {},\n    ): Promise<LangChaingoSQLResponse> {\n        return this.client.send(`${this.basePath()}/sql`, {\n            method: \"POST\",\n            body: payload,\n            ...options,\n        });\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { SendOptions } from \"@/tools/options\";\n\nexport interface GraphQLResponse<T = any> {\n    data?: T;\n    errors?: Array<{ message: string; [key: string]: any }>;\n    extensions?: Record<string, any>;\n}\n\nexport interface GraphQLRequestOptions extends SendOptions {\n    operationName?: string;\n    variables?: Record<string, any>;\n}\n\nexport class GraphQLService extends BaseService {\n    async query<T = any>(\n        query: string,\n        variables?: Record<string, any> | null,\n        options?: GraphQLRequestOptions,\n    ): Promise<GraphQLResponse<T>> {\n        const { operationName, variables: optionVariables, ...sendOptions } =\n            options || {};\n\n        return this.client.send<GraphQLResponse<T>>(\"/api/graphql\", {\n            ...sendOptions,\n            method: sendOptions.method || \"POST\",\n            body: {\n                query,\n                operationName,\n                variables: variables ?? optionVariables ?? {},\n            },\n        });\n    }\n}\n","import Client from \"@/Client\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\n\nexport interface PubSubMessage<T = any> {\n    id: string;\n    topic: string;\n    created: string;\n    data: T;\n}\n\nexport interface PublishAck {\n    id: string;\n    topic: string;\n    created: string;\n}\n\ntype PendingResolver<T> = {\n    resolve: (value: T) => void;\n    reject: (reason: any) => void;\n    timer?: any;\n};\n\nexport class PubSubService extends BaseService {\n    private socket: WebSocket | null = null;\n    private pendingConnects: Array<PendingResolver<void>> = [];\n    private pendingAcks: Map<string, PendingResolver<any>> = new Map();\n    private subscriptions: Record<string, Set<(msg: PubSubMessage) => void>> = {};\n    private reconnectAttempts = 0;\n    private reconnectTimeoutId: any;\n    private connectTimeoutId: any;\n    private manualClose = false;\n    private readonly maxConnectTimeout = 15000;\n    private readonly ackTimeoutMs = 10000;\n    private readonly predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private readonly maxReconnectAttempts = Infinity;\n\n    constructor(client: Client) {\n        super(client);\n    }\n\n    /**\n     * Indicates whether the websocket is connected.\n     */\n    get isConnected(): boolean {\n        return !!this.socket && this.socket.readyState === WebSocket.OPEN;\n    }\n\n    /**\n     * Publish a message to a topic. Resolves when the server acknowledges it.\n     */\n    async publish<T = any>(topic: string, data: T): Promise<PublishAck> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        await this.ensureSocket();\n\n        const requestId = this.nextRequestId();\n        const ackPromise = this.waitForAck<PublishAck>(requestId, (payload) => ({\n            id: payload?.id,\n            topic: payload?.topic || topic,\n            created: payload?.created,\n        }));\n\n        await this.sendEnvelope({\n            type: \"publish\",\n            topic: topic,\n            data,\n            requestId,\n        });\n\n        return ackPromise;\n    }\n\n    /**\n     * Subscribe to a topic. Returns an async unsubscribe function.\n     */\n    async subscribe(\n        topic: string,\n        callback: (data: PubSubMessage) => void,\n    ): Promise<() => Promise<void>> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        let isFirstListener = false;\n        if (!this.subscriptions[topic]) {\n            this.subscriptions[topic] = new Set();\n            isFirstListener = true;\n        }\n        this.subscriptions[topic].add(callback);\n\n        await this.ensureSocket();\n\n        if (isFirstListener) {\n            const requestId = this.nextRequestId();\n            const ackPromise = this.waitForAck<boolean>(requestId).catch(() => {});\n            await this.sendEnvelope({\n                type: \"subscribe\",\n                topic: topic,\n                requestId,\n            });\n            await ackPromise;\n        }\n\n        return async () => {\n            this.subscriptions[topic]?.delete(callback);\n            if (this.subscriptions[topic]?.size === 0) {\n                delete this.subscriptions[topic];\n                await this.sendUnsubscribe(topic);\n            }\n\n            if (!this.hasSubscriptions()) {\n                this.disconnect();\n            }\n        };\n    }\n\n    /**\n     * Unsubscribe from a specific topic or from all topics.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        if (topic) {\n            delete this.subscriptions[topic];\n            await this.sendUnsubscribe(topic);\n        } else {\n            this.subscriptions = {};\n            if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n                await this.sendEnvelope({ type: \"unsubscribe\" });\n            }\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Close the websocket connection and clear pending requests.\n     */\n    disconnect(): void {\n        this.manualClose = true;\n        this.rejectAllPending(new Error(\"pubsub connection closed\"));\n        this.closeSocket();\n        this.pendingConnects = [];\n    }\n\n    private hasSubscriptions(): boolean {\n        return Object.keys(this.subscriptions).length > 0;\n    }\n\n    private buildWebSocketURL(): string {\n        const raw = this.client.buildURL(\"/api/pubsub\");\n        let url: URL;\n\n        try {\n            url = new URL(\n                raw,\n                typeof window !== \"undefined\" ? window.location.href : \"http://localhost\",\n            );\n        } catch {\n            url = new URL(\"http://localhost\");\n        }\n\n        const token = this.client.authStore?.token;\n        if (token) {\n            url.searchParams.set(\"token\", token);\n        }\n\n        if (url.protocol === \"https:\") {\n            url.protocol = \"wss:\";\n        } else if (url.protocol === \"http:\") {\n            url.protocol = \"ws:\";\n        } else if (!url.protocol || url.protocol === \":\") {\n            url.protocol = \"ws:\";\n        }\n\n        return url.toString();\n    }\n\n    private nextRequestId(): string {\n        return Math.random().toString(36).substring(2) + Date.now().toString(36);\n    }\n\n    private async ensureSocket(): Promise<void> {\n        if (this.isConnected) {\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                return;\n            }\n\n            this.initConnect();\n        });\n    }\n\n    private initConnect() {\n        this.closeSocket(true);\n        this.manualClose = false;\n\n        let url: string;\n        try {\n            url = this.buildWebSocketURL();\n        } catch (err: any) {\n            this.connectErrorHandler(err);\n            return;\n        }\n\n        if (typeof WebSocket === \"undefined\") {\n            this.connectErrorHandler(\n                new Error(\"WebSocket is not available in this runtime environment.\"),\n            );\n            return;\n        }\n\n        try {\n            this.socket = new WebSocket(url);\n        } catch (err: any) {\n            this.connectErrorHandler(err);\n            return;\n        }\n\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"WebSocket connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.socket.onmessage = (event) => this.handleMessage(event.data);\n        this.socket.onerror = () => {\n            this.connectErrorHandler(\n                new ClientResponseError(\"WebSocket connection failed.\"),\n            );\n        };\n        this.socket.onclose = () => {\n            this.handleClose();\n        };\n    }\n\n    private handleMessage(payload: any) {\n        clearTimeout(this.connectTimeoutId);\n\n        if (typeof payload !== \"string\") {\n            return;\n        }\n\n        let data: any = null;\n        try {\n            data = JSON.parse(payload);\n        } catch {\n            return;\n        }\n\n        switch (data?.type) {\n            case \"ready\":\n                this.handleConnected();\n                break;\n            case \"message\": {\n                const topic = data.topic || \"\";\n                const listeners = this.subscriptions[topic];\n                if (!listeners) {\n                    return;\n                }\n                const message: PubSubMessage = {\n                    id: data.id,\n                    topic: topic,\n                    created: data.created,\n                    data: data.data,\n                };\n                listeners.forEach((cb) => {\n                    try {\n                        cb(message);\n                    } catch (_) {}\n                });\n                break;\n            }\n            case \"published\":\n            case \"subscribed\":\n            case \"unsubscribed\":\n            case \"pong\":\n                this.resolvePending(data.requestId, data);\n                break;\n            case \"error\": {\n                const err = new Error(data.message || \"pubsub error\");\n                if (data.requestId) {\n                    this.rejectPending(data.requestId, err);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    private handleConnected() {\n        const shouldResubscribe = this.reconnectAttempts > 0;\n        this.reconnectAttempts = 0;\n        clearTimeout(this.reconnectTimeoutId);\n        clearTimeout(this.connectTimeoutId);\n\n        for (let p of this.pendingConnects) {\n            p.resolve();\n        }\n        this.pendingConnects = [];\n\n        if (shouldResubscribe) {\n            Object.keys(this.subscriptions).forEach((topic) => {\n                const requestId = this.nextRequestId();\n                this.sendEnvelope({\n                    type: \"subscribe\",\n                    topic,\n                    requestId,\n                });\n            });\n        }\n    }\n\n    private handleClose() {\n        this.socket = null;\n\n        if (this.manualClose) {\n            return;\n        }\n\n        this.rejectAllPending(new Error(\"pubsub connection closed\"));\n\n        if (!this.hasSubscriptions()) {\n            this.pendingConnects = [];\n            return;\n        }\n\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        if (this.reconnectAttempts <= this.maxReconnectAttempts) {\n            this.reconnectAttempts++;\n            clearTimeout(this.reconnectTimeoutId);\n            this.reconnectTimeoutId = setTimeout(() => this.initConnect(), timeout);\n        }\n    }\n\n    private async sendEnvelope(data: any): Promise<void> {\n        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n            await this.ensureSocket();\n        }\n\n        if (!this.socket) {\n            throw new Error(\"Unable to send websocket message - socket not initialized.\");\n        }\n\n        this.socket.send(JSON.stringify(data));\n    }\n\n    private async sendUnsubscribe(topic: string): Promise<void> {\n        if (!this.socket) {\n            return;\n        }\n\n        const requestId = this.nextRequestId();\n        const ackPromise = this.waitForAck<boolean>(requestId).catch(() => {});\n        await this.sendEnvelope({\n            type: \"unsubscribe\",\n            topic,\n            requestId,\n        });\n        await ackPromise;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n\n        if (this.reconnectAttempts > this.maxReconnectAttempts || this.manualClose) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.closeSocket();\n            return;\n        }\n\n        this.closeSocket(true);\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        this.reconnectAttempts++;\n        clearTimeout(this.reconnectTimeoutId);\n        this.reconnectTimeoutId = setTimeout(() => this.initConnect(), timeout);\n    }\n\n    private closeSocket(keepSubscriptions = false) {\n        if (this.socket) {\n            try {\n                this.socket.onclose = null;\n                this.socket.onerror = null;\n                this.socket.onmessage = null;\n                this.socket.close();\n            } catch (_) {}\n        }\n        this.socket = null;\n\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (!keepSubscriptions) {\n            this.subscriptions = {};\n            this.pendingAcks.clear();\n        }\n    }\n\n    private waitForAck<T = any>(\n        requestId: string,\n        mapper?: (payload: any) => T,\n    ): Promise<T> {\n        return new Promise((resolve, reject) => {\n            const timer = setTimeout(() => {\n                this.pendingAcks.delete(requestId);\n                reject(new Error(\"Timed out waiting for pubsub response.\"));\n            }, this.ackTimeoutMs);\n\n            this.pendingAcks.set(requestId, {\n                resolve: (payload: any) => {\n                    clearTimeout(timer);\n                    this.pendingAcks.delete(requestId);\n                    resolve(mapper ? mapper(payload) : (payload as T));\n                },\n                reject: (err: any) => {\n                    clearTimeout(timer);\n                    this.pendingAcks.delete(requestId);\n                    reject(err);\n                },\n            });\n        });\n    }\n\n    private resolvePending(requestId: string, payload: any) {\n        const pending = requestId ? this.pendingAcks.get(requestId) : null;\n        pending?.resolve(payload);\n    }\n\n    private rejectPending(requestId: string, err: any) {\n        const pending = requestId ? this.pendingAcks.get(requestId) : null;\n        pending?.reject(err);\n    }\n\n    private rejectAllPending(err: any) {\n        for (let pending of this.pendingAcks.values()) {\n            pending.reject(err);\n        }\n        this.pendingAcks.clear();\n\n        for (let p of this.pendingConnects) {\n            p.reject(err);\n        }\n        this.pendingConnects = [];\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { LocalAuthStore } from \"@/stores/LocalAuthStore\";\nimport { SettingsService } from \"@/services/SettingsService\";\nimport { RecordService } from \"@/services/RecordService\";\nimport { CollectionService } from \"@/services/CollectionService\";\nimport { LogService } from \"@/services/LogService\";\nimport { RealtimeService } from \"@/services/RealtimeService\";\nimport { HealthService } from \"@/services/HealthService\";\nimport { FileService } from \"@/services/FileService\";\nimport { BackupService } from \"@/services/BackupService\";\nimport { CronService } from \"@/services/CronService\";\nimport { BatchService } from \"@/services/BatchService\";\nimport { VectorService } from \"@/services/VectorService\";\nimport { LLMDocumentService } from \"@/services/LLMDocumentService\";\nimport { CacheService } from \"@/services/CacheService\";\nimport { LangChaingoService } from \"@/services/LangChaingoService\";\nimport { GraphQLService } from \"@/services/GraphQLService\";\nimport { PubSubService } from \"@/services/PubSubService\";\nimport { RecordModel } from \"@/tools/dtos\";\nimport {\n    SendOptions,\n    FileOptions,\n    normalizeUnknownQueryParams,\n    serializeQueryParams,\n} from \"@/tools/options\";\nimport { isFormData, convertToFormDataIfNeeded } from \"@/tools/formdata\";\n\nexport interface BeforeSendResult {\n    [key: string]: any; // for backward compatibility\n    url?: string;\n    options?: { [key: string]: any };\n}\n\n/**\n * BosBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base BosBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseURL: string;\n\n    /**\n     * Legacy getter alias for baseURL.\n     * @deprecated Please replace with baseURL.\n     */\n    get baseUrl(): string {\n        return this.baseURL;\n    }\n\n    /**\n     * Legacy setter alias for baseURL.\n     * @deprecated Please replace with baseURL.\n     */\n    set baseUrl(v: string) {\n        this.baseURL = v;\n    }\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * const pb = new BosBase(\"https://example.com\")\n     *\n     * pb.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     })\n     *\n     *     return { url, options }\n     * }\n     *\n     * // use the created client as usual...\n     * ```\n     */\n    beforeSend?: (\n        url: string,\n        options: SendOptions,\n    ) => BeforeSendResult | Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * const pb = new BosBase(\"https://example.com\")\n     *\n     * pb.afterSend = function (response, data, options) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             response: { ... },\n     *         })\n     *     }\n     *\n     *     return data;\n     * }\n     *\n     * // use the created client as usual...\n     * ```\n     */\n    afterSend?: ((response: Response, data: any) => any) &\n        ((response: Response, data: any, options: SendOptions) => any);\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **WebSocket pub/sub APIs**.\n     */\n    readonly pubsub: PubSubService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    /**\n     * An instance of the service that handles the **Cron APIs**.\n     */\n    readonly crons: CronService;\n\n    /**\n     * An instance of the service that handles the **Vector APIs**.\n     */\n    readonly vectors: VectorService;\n\n    /**\n     * An instance of the service that handles the **LLM Document APIs**.\n     */\n    readonly llmDocuments: LLMDocumentService;\n\n    /**\n     * An instance of the service that handles the **LangChaingo APIs**.\n     */\n    readonly langchaingo: LangChaingoService;\n\n    /**\n     * An instance of the service that handles the **Cache APIs**.\n     */\n    readonly caches: CacheService;\n\n    /**\n     * An instance of the service that handles **GraphQL queries**.\n     */\n    readonly graphql: GraphQLService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(baseURL = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\n        this.baseURL = baseURL;\n        this.lang = lang;\n\n        if (authStore) {\n            this.authStore = authStore;\n        } else if (typeof window != \"undefined\" && !!(window as any).Deno) {\n            // note: to avoid common security issues we fallback to runtime/memory store in case the code is running in Deno env\n            this.authStore = new BaseAuthStore();\n        } else {\n            this.authStore = new LocalAuthStore();\n        }\n\n        // common services\n        this.collections = new CollectionService(this);\n        this.files = new FileService(this);\n        this.logs = new LogService(this);\n        this.settings = new SettingsService(this);\n        this.realtime = new RealtimeService(this);\n        this.pubsub = new PubSubService(this);\n        this.health = new HealthService(this);\n        this.backups = new BackupService(this);\n        this.crons = new CronService(this);\n        this.vectors = new VectorService(this);\n        this.llmDocuments = new LLMDocumentService(this);\n        this.langchaingo = new LangChaingoService(this);\n        this.caches = new CacheService(this);\n        this.graphql = new GraphQLService(this);\n    }\n\n    /**\n     * @deprecated\n     * With BosBase v0.23.0 admins are converted to a regular auth\n     * collection named \"_superusers\", aka. you can use directly collection(\"_superusers\").\n     */\n    get admins(): RecordService {\n        return this.collection(\"_superusers\");\n    }\n\n    /**\n     * Creates a new batch handler for sending multiple transactional\n     * create/update/upsert/delete collection requests in one network call.\n     *\n     * Example:\n     * ```js\n     * const batch = pb.createBatch();\n     *\n     * batch.collection(\"example1\").create({ ... })\n     * batch.collection(\"example2\").update(\"RECORD_ID\", { ... })\n     * batch.collection(\"example3\").delete(\"RECORD_ID\")\n     * batch.collection(\"example4\").upsert({ ... })\n     *\n     * await batch.send()\n     * ```\n     */\n    createBatch(): BatchService {\n        return new BatchService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     */\n    collection<M = RecordModel>(idOrName: string): RecordService<M> {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(requestKey: string): Client {\n        if (this.cancelControllers[requestKey]) {\n            this.cancelControllers[requestKey].abort();\n            delete this.cancelControllers[requestKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Constructs a filter expression with placeholders populated from a parameters object.\n     *\n     * Placeholder parameters are defined with the `{:paramName}` notation.\n     *\n     * The following parameter values are supported:\n     *\n     * - `string` (_single quotes are autoescaped_)\n     * - `number`\n     * - `boolean`\n     * - `Date` object (_stringified into the BosBase datetime format_)\n     * - `null`\n     * - everything else is converted to a string using `JSON.stringify()`\n     *\n     * Example:\n     *\n     * ```js\n     * pb.collection(\"example\").getFirstListItem(pb.filter(\n     *    'title ~ {:title} && created >= {:created}',\n     *    { title: \"example\", created: new Date()}\n     * ))\n     * ```\n     */\n    filter(raw: string, params?: { [key: string]: any }): string {\n        if (!params) {\n            return raw;\n        }\n\n        for (let key in params) {\n            let val = params[key];\n            switch (typeof val) {\n                case \"boolean\":\n                case \"number\":\n                    val = \"\" + val;\n                    break;\n                case \"string\":\n                    val = \"'\" + val.replace(/'/g, \"\\\\'\") + \"'\";\n                    break;\n                default:\n                    if (val === null) {\n                        val = \"null\";\n                    } else if (val instanceof Date) {\n                        val = \"'\" + val.toISOString().replace(\"T\", \" \") + \"'\";\n                    } else {\n                        val = \"'\" + JSON.stringify(val).replace(/'/g, \"\\\\'\") + \"'\";\n                    }\n            }\n            raw = raw.replaceAll(\"{:\" + key + \"}\", val);\n        }\n\n        return raw;\n    }\n\n    /**\n     * @deprecated Please use `pb.files.getURL()`.\n     */\n    getFileUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        console.warn(\"Please replace pb.getFileUrl() with pb.files.getURL()\");\n        return this.files.getURL(record, filename, queryParams);\n    }\n\n    /**\n     * @deprecated Please use `pb.buildURL()`.\n     */\n    buildUrl(path: string): string {\n        console.warn(\"Please replace pb.buildUrl() with pb.buildURL()\");\n        return this.buildURL(path);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildURL(path: string): string {\n        let url = this.baseURL;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== \"undefined\" &&\n            !!window.location &&\n            !url.startsWith(\"https://\") &&\n            !url.startsWith(\"http://\")\n        ) {\n            url = window.location.origin?.endsWith(\"/\")\n                ? window.location.origin.substring(0, window.location.origin.length - 1)\n                : window.location.origin || \"\";\n\n            if (!this.baseURL.startsWith(\"/\")) {\n                url += window.location.pathname || \"/\";\n                url += url.endsWith(\"/\") ? \"\" : \"/\";\n            }\n\n            url += this.baseURL;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith(\"/\") ? \"\" : \"/\"; // append trailing slash if missing\n            url += path.startsWith(\"/\") ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Sends an api http request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\n        options = this.initSendOptions(path, options);\n\n        // build url + path\n        let url = this.buildURL(path);\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (\n                typeof result.url !== \"undefined\" ||\n                typeof result.options !== \"undefined\"\n            ) {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn &&\n                    console.warn(\n                        \"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\",\n                    );\n            }\n        }\n\n        // serialize the query parameters\n        if (typeof options.query !== \"undefined\") {\n            const query = serializeQueryParams(options.query);\n            if (query) {\n                url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n            delete options.query;\n        }\n\n        // ensures that the json body is serialized\n        if (\n            this.getHeader(options.headers, \"Content-Type\") == \"application/json\" &&\n            options.body &&\n            typeof options.body !== \"string\"\n        ) {\n            options.body = JSON.stringify(options.body);\n        }\n\n        const fetchFunc = options.fetch || fetch;\n\n        // send the request\n        return fetchFunc(url, options)\n            .then(async (response) => {\n                let data: any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data, options);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url: response.url,\n                        status: response.status,\n                        data: data,\n                    });\n                }\n\n                return data as T;\n            })\n            .catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Shallow copy the provided object and takes care to initialize\n     * any options required to preserve the backward compatability.\n     *\n     * @param  {SendOptions} options\n     * @return {SendOptions}\n     */\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\n        options = Object.assign({ method: \"GET\" } as SendOptions, options);\n\n        // auto convert the body to FormData, if needed\n        options.body = convertToFormDataIfNeeded(options.body);\n\n        // move unknown send options as query parameters\n        normalizeUnknownQueryParams(options);\n\n        // requestKey normalizations for backward-compatibility\n        // ---\n        options.query = Object.assign({}, options.params, options.query);\n        if (typeof options.requestKey === \"undefined\") {\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\n                options.requestKey = null;\n            } else if (options.$cancelKey || options.query.$cancelKey) {\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\n            }\n        }\n        // remove the deprecated special cancellation params from the other query params\n        delete options.$autoCancel;\n        delete options.query.$autoCancel;\n        delete options.$cancelKey;\n        delete options.query.$cancelKey;\n        // ---\n\n        // add the json header, if not explicitly set\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (\n            this.getHeader(options.headers, \"Content-Type\") === null &&\n            !isFormData(options.body)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Content-Type\": \"application/json\",\n            });\n        }\n\n        // add Accept-Language header, if not explicitly set\n        if (this.getHeader(options.headers, \"Accept-Language\") === null) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Accept-Language\": this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has valid token\n            this.authStore.token &&\n            // auth header is not explicitly set\n            this.getHeader(options.headers, \"Authorization\") === null\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                Authorization: this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.requestKey !== null) {\n            const requestKey = options.requestKey || (options.method || \"GET\") + path;\n\n            delete options.requestKey;\n\n            // cancel previous pending requests\n            this.cancelRequest(requestKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[requestKey] = controller;\n            options.signal = controller.signal;\n        }\n\n        return options;\n    }\n\n    /**\n     * Extracts the header with the provided name in case-insensitive manner.\n     * Returns `null` if no header matching the name is found.\n     */\n    private getHeader(\n        headers: { [key: string]: string } | undefined,\n        name: string,\n    ): string | null {\n        headers = headers || {};\n        name = name.toLowerCase();\n\n        for (let key in headers) {\n            if (key.toLowerCase() == name) {\n                return headers[key];\n            }\n        }\n\n        return null;\n    }\n}\n","import { BaseAuthStore, AuthRecord } from \"@/stores/BaseAuthStore\";\n\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\n\nexport type AsyncClearFunc = () => Promise<void>;\n\ntype queueFunc = () => Promise<void>;\n\n/**\n * AsyncAuthStore is a helper auth store implementation\n * that could be used with any external async persistent layer\n * (key-value db, local file, etc.).\n *\n * Here is an example with the React Native AsyncStorage package:\n *\n * ```\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\n * import BosBase, { AsyncAuthStore } from \"bosbase\";\n *\n * const store = new AsyncAuthStore({\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\n *     initial: AsyncStorage.getItem(\"pb_auth\"),\n * });\n *\n * const pb = new BosBase(\"https://example.com\", store)\n * ```\n */\nexport class AsyncAuthStore extends BaseAuthStore {\n    private saveFunc: AsyncSaveFunc;\n    private clearFunc?: AsyncClearFunc;\n    private queue: Array<queueFunc> = [];\n\n    constructor(config: {\n        // The async function that is called every time\n        // when the auth store state needs to be persisted.\n        save: AsyncSaveFunc;\n\n        /// An *optional* async function that is called every time\n        /// when the auth store needs to be cleared.\n        ///\n        /// If not explicitly set, `saveFunc` with empty data will be used.\n        clear?: AsyncClearFunc;\n\n        // An *optional* initial data to load into the store.\n        initial?: string | Promise<any>;\n    }) {\n        super();\n\n        this.saveFunc = config.save;\n        this.clearFunc = config.clear;\n\n        this._enqueue(() => this._loadInitial(config.initial));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, record?: AuthRecord): void {\n        super.save(token, record);\n\n        let value = \"\";\n        try {\n            value = JSON.stringify({ token, record });\n        } catch (err) {\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n        }\n\n        this._enqueue(() => this.saveFunc(value));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear(): void {\n        super.clear();\n\n        if (this.clearFunc) {\n            this._enqueue(() => this.clearFunc!());\n        } else {\n            this._enqueue(() => this.saveFunc(\"\"));\n        }\n    }\n\n    /**\n     * Initializes the auth store state.\n     */\n    private async _loadInitial(payload?: string | Promise<any>) {\n        try {\n            payload = await payload;\n\n            if (payload) {\n                let parsed;\n                if (typeof payload === \"string\") {\n                    parsed = JSON.parse(payload) || {};\n                } else if (typeof payload === \"object\") {\n                    parsed = payload;\n                }\n\n                this.save(parsed.token || \"\", parsed.record || parsed.model || null);\n            }\n        } catch (_) {}\n    }\n\n    /**\n     * Appends an async function to the queue.\n     */\n    private _enqueue(asyncCallback: () => Promise<void>) {\n        this.queue.push(asyncCallback);\n\n        if (this.queue.length == 1) {\n            this._dequeue();\n        }\n    }\n\n    /**\n     * Starts the queue processing.\n     */\n    private _dequeue() {\n        if (!this.queue.length) {\n            return;\n        }\n\n        this.queue[0]().finally(() => {\n            this.queue.shift();\n\n            if (!this.queue.length) {\n                return;\n            }\n\n            this._dequeue();\n        });\n    }\n}\n"],"names":["ClientResponseError","Error","constructor","errData","super","this","url","status","response","isAbort","originalError","Object","setPrototypeOf","prototype","data","DOMException","name","message","cause","includes","toJSON","fieldContentRegExp","cookieParse","str","options","result","decode","assign","defaultDecode","index","length","eqIdx","indexOf","endIdx","lastIndexOf","key","slice","trim","undefined","val","charCodeAt","_","cookieSerialize","opt","encode","defaultEncode","test","TypeError","value","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","call","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","decodeURIComponent","encodeURIComponent","isReactNative","navigator","product","global","HermesInternal","atobPolyfill","getTokenPayload","token","encodedPayload","split","map","c","join","JSON","parse","e","isTokenExpired","expirationThreshold","payload","keys","exp","now","atob","input","String","replace","bs","buffer","bc","idx","output","charAt","fromCharCode","defaultCookieKey","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","record","model","isValid","isSuperuser","type","collectionName","collectionId","isAdmin","console","warn","isAuthRecord","save","triggerChange","clear","loadFromCookie","cookie","rawData","Array","isArray","exportToCookie","defaultOptions","stringify","resultLength","Blob","size","id","email","extraProps","prop","onChange","callback","fireImmediately","push","i","splice","LocalAuthStore","storageKey","storageFallback","_bindStorageEvent","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","addEventListener","BaseService","client","SettingsService","getAll","method","send","update","bodyParams","body","testS3","filesystem","then","testEmail","collectionIdOrName","toEmail","emailTemplate","template","collection","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","getCategory","category","updateMeta","config","meta","getApplicationSettings","allSettings","trustedProxy","rateLimits","batch","updateApplicationSettings","updateSMTP","smtp","getMailSettings","senderName","senderAddress","updateMailSettings","updateBody","testMail","updateS3","s3","getStorageS3","updateStorageS3","testStorageS3","updateBackups","backups","getBackupSettings","updateBackupSettings","setAutoBackupSchedule","cron","cronMaxKeep","disableAutoBackup","testBackupsS3","updateBatch","updateRateLimits","updateTrustedProxy","updateLogs","logs","getLogSettings","updateLogSettings","setLogRetentionDays","maxDays","setMinLogLevel","minLevel","setLogIPAddresses","enabled","logIP","setLogAuthIds","logAuthId","knownSendOptionsKeys","normalizeUnknownQueryParams","query","serializeQueryParams","params","encodedKey","arrValue","v","prepareQueryParamValue","toISOString","RealtimeService","eventSource","subscriptions","lastSentSubscriptions","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","isConnected","subscribe","topic","serialized","headers","listener","msgEvent","submitSubscriptions","connect","async","unsubscribeByTopicAndListener","unsubscribe","needToSubmit","subs","getSubscriptionsByTopic","hasSubscriptionListeners","removeEventListener","disconnect","unsubscribeByPrefix","keyPrefix","hasAtleastOneTopic","startsWith","exist","keyToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionKeys","requestKey","getSubscriptionsCancelKey","catch","err","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","buildURL","onerror","lastEventId","retries","hasUnsentSubscriptions","p","reconnectTimeoutId","connectSubs","latestTopics","t","timeout","fromReconnect","onDisconnect","cancelRequest","close","CrudService","getFullList","batchOrqueryParams","_getFullList","getList","page","perPage","baseCrudPath","responseData","items","item","getFirstListItem","filter","skipTotal","code","getOne","create","batchSize","request","list","concat","normalizeLegacyOptionsArgs","legacyWarn","baseOptions","bodyOrOptions","hasQuery","resetAutoRefresh","_resetAutoRefresh","RecordService","baseCollectionPath","isSuperusers","realtime","batchOrOptions","getCount","count","authStore","authExpand","expand","authRecord","delete","success","authResponse","listAuthMethods","fields","authWithPassword","usernameOrEmail","password","autoRefreshThreshold","identity","autoRefresh","authData","registerAutoRefresh","threshold","refreshFunc","reauthenticateFunc","oldBeforeSend","beforeSend","oldModel","unsubStoreChange","newToken","sendOptions","oldToken","authRefresh","authWithOAuth2Code","provider","codeVerifier","redirectURL","createData","authWithOAuth2","args","eagerDefaultPopup","urlCallback","openBrowserPopup","cleanup","requestKeyOptions","authMethods","oauth2","providers","find","cancelController","signal","onabort","oldState","state","error","scopes","replacements","_replaceQueryParams","authURL","location","href","requestPasswordReset","confirmPasswordReset","passwordResetToken","passwordConfirm","requestVerification","confirmVerification","verificationToken","verified","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","recordId","unlinkExternalAuth","ea","requestOTP","authWithOTP","otpId","impersonate","Authorization","Client","baseURL","lang","urlPath","substring","parsedParams","rawParams","param","pair","hasOwnProperty","open","width","height","windowWidth","innerWidth","windowHeight","innerHeight","left","top","CollectionService","deleteCollection","getScaffolds","createFromScaffold","overrides","scaffold","createBase","createAuth","createView","viewQuery","scaffoldOverrides","truncate","registerSqlTables","tables","importSqlTables","exportCollections","filterCollections","collections","cleaned","created","updated","normalizeForImport","seenIds","Set","has","add","normalized","seenFieldIds","field","import","deleteMissing","addField","f","newField","system","hidden","presentable","required","updateField","fieldName","updates","fieldIndex","findIndex","removeField","indexes","getField","addIndex","columns","unique","indexName","fieldNames","column","idxName","columnsStr","col","removeIndex","initialLength","every","getIndexes","setListRule","rule","listRule","setViewRule","viewRule","setCreateRule","createRule","setUpdateRule","updateRule","setDeleteRule","deleteRule","setRules","rules","getRules","setManageRule","manageRule","setAuthRule","authRule","getSchema","getAllSchemas","enableOAuth2","authCollection","mappedFields","disableOAuth2","getOAuth2Config","setOAuth2MappedFields","addOAuth2Provider","clientSecret","tokenURL","userInfoURL","displayName","pkce","extra","updateOAuth2Provider","providerName","providerIndex","removeOAuth2Provider","LogService","getStats","HealthService","check","FileService","getUrl","filename","queryParams","getURL","parts","download","URLSearchParams","getToken","BackupService","basename","upload","restore","getDownloadUrl","getDownloadURL","CronService","run","jobId","isFile","File","uri","isFormData","FormData","hasFileField","values","inferNumberCharsRegex","inferFormDataValue","num","BatchService","requests","SubBatchService","formData","jsonData","req","json","files","file","append","upsert","prepareRequest","convertFormDataToObject","forEach","k","parsed","foundFiles","foundRegular","fileKey","endsWith","VectorService","baseVectorPath","requireCollection","getPath","insert","document","batchInsert","search","searchOptions","get","createCollection","updateCollection","listCollections","LLMDocumentService","basePath","collectionsPath","collectionPath","metadata","CacheService","setEntry","cache","ttlSeconds","getEntry","renewEntry","deleteEntry","LangChaingoService","completions","rag","queryDocuments","sql","GraphQLService","variables","operationName","optionVariables","PubSubService","socket","pendingAcks","Map","manualClose","ackTimeoutMs","readyState","WebSocket","OPEN","publish","ensureSocket","requestId","nextRequestId","ackPromise","waitForAck","sendEnvelope","isFirstListener","sendUnsubscribe","hasSubscriptions","rejectAllPending","closeSocket","buildWebSocketURL","raw","URL","searchParams","set","protocol","random","onmessage","event","handleMessage","onclose","handleClose","handleConnected","listeners","cb","resolvePending","rejectPending","shouldResubscribe","keepSubscriptions","mapper","timer","pending","baseUrl","cancelControllers","recordServices","enableAutoCancellation","Deno","settings","pubsub","health","crons","vectors","llmDocuments","langchaingo","caches","graphql","admins","createBatch","idOrName","autoCancellation","enable","abort","cancelAllRequests","replaceAll","getFileUrl","buildUrl","origin","pathname","initSendOptions","getHeader","fetch","afterSend","convertToFormDataIfNeeded","form","$autoCancel","$cancelKey","controller","AbortController","AsyncAuthStore","queue","saveFunc","clearFunc","_enqueue","_loadInitial","initial","asyncCallback","_dequeue","finally","shift"],"mappings":"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"}